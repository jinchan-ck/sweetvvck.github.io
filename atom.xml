<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Sweetvvck]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://sweetvvck.github.io/"/>
  <updated>2016-01-25T20:06:13.000Z</updated>
  <id>http://sweetvvck.github.io/</id>
  
  <author>
    <name><![CDATA[Sweetvvck]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[[译]打造atom成为golang开发神器]]></title>
    <link href="http://sweetvvck.github.io/2015/12/29/%E8%AF%91-%E6%89%93%E9%80%A0atom%E6%88%90%E4%B8%BAgolang%E5%BC%80%E5%8F%91%E7%A5%9E%E5%99%A8/"/>
    <id>http://sweetvvck.github.io/2015/12/29/译-打造atom成为golang开发神器/</id>
    <published>2015-12-28T16:37:30.000Z</published>
    <updated>2016-01-25T20:06:13.000Z</updated>
    <content type="html"><![CDATA[<p>在我在Windows系统上开发的日子里，我使用IDE开发数年之久，例如Visual Basic IDE, Borland Delphi IDE, Visual C&#43;&#43; 和最后的Visual Studio；但当我在大约10年前转到Mac OS X下开发后，我放弃了上述所有的IDE。</p>
<p>我刚进入Mac编程世界的时候使用的是当时表现极好的Textmate编辑器。它是一个开发代码飞快的编辑器，拥有很好的语法高亮，拓展模块以及代码片段(code snippets)，让我再次感觉非常高产。经过几年的衰退期，由于它没有继续更新了，很多人转向了Sublime Text和传统的VIM编辑器了。</p>
<p>Atom刚出来的时候我尝试使用了一下，但当时它并没有准备好。而最近几天它正式发布官方1.0版本后我决定再次试用一下，我很高兴我又试用了下atom。</p>
<p><a href="https://atom.io/" target="_blank" rel="external">https://atom.io/</a></p>
<h2 id="u5B89_u88C5_u4E3B_u9898"><a href="#u5B89_u88C5_u4E3B_u9898" class="headerlink" title="安装主题"></a>安装主题</h2><p>你一天将要花大部分时间看着代码，注视着你的编辑器，因此你总是必须要找到一个颜色搭配自然的主题，并且要能够让你的&#30524;睛觉得舒服。我认为这个因人而异，你需要找一个你最喜欢的。</p>
<p>我现在一直使用的主题是One Dark UI Theme和Monokai-Seti Syntax theme(译者注：atom的主题分为UI主题和语法主题)，我很享受使用这样的主题搭配。</p>
<p><img src="http://marcio.io/img/atom-theme.png" alt="atom-theme"></p>
<p>下图是这样的主题搭配在我的电脑上的效果:</p>
<p><img src="http://marcio.io/img/atom-editor.png" alt="atom-editor"></p>
<h4 id="monokai-seti"><a href="#monokai-seti" class="headerlink" title="monokai-seti"></a>monokai-seti</h4><ul>
<li><a href="https://atom.io/packages/monokai-seti" target="_blank" rel="external">https://atom.io/packages/monokai-seti</a></li>
</ul>
<h2 id="u5B89_u88C5_u5F00_u53D1_u4E13_u7528_u5B57_u4F53"><a href="#u5B89_u88C5_u5F00_u53D1_u4E13_u7528_u5B57_u4F53" class="headerlink" title="安装开发专用字体"></a>安装开发专用字体</h2><p>我第一次打开atom想做的第一件事情是：安装一个我更喜欢的开发专用字体，我使用免费字体“Inconsolata”有一阵子了。</p>
<p>你可以通过这个链接查看和下载这个字体：<a href="http://www.levien.com/type/myfonts/inconsolata.html" target="_blank" rel="external">http://www.levien.com/type/myfonts/inconsolata.html</a></p>
<p>你可以使用标准的编辑器设置很便捷的切换正在使用的字体。</p>
<h2 id="u5B89_u88C5_u5F00_u53D1_u8BED_u8A00_u5305"><a href="#u5B89_u88C5_u5F00_u53D1_u8BED_u8A00_u5305" class="headerlink" title="安装开发语言包"></a>安装开发语言包</h2><p>Atom自带的标准包里涵盖了大部分开发语言。我做Go开发还差两个语言包，分别是Dockerfile语法和Google Protobuf语法，这两个在我的项目中大量被使用到。</p>
<ul>
<li>language-docker:&nbsp;<a href="https://atom.io/packages/language-docker" target="_blank" rel="external">https://atom.io/packages/language-docker</a></li>
<li>language-protobuf:&nbsp;<a href="https://atom.io/packages/language-protobuf" target="_blank" rel="external">https://atom.io/packages/language-protobuf</a></li>
</ul>
<h2 id="u5B89_u88C5_u63D2_u4EF6"><a href="#u5B89_u88C5_u63D2_u4EF6" class="headerlink" title="安装插件"></a>安装插件</h2><h4 id="go-plus"><a href="#go-plus" class="headerlink" title="go-plus"></a>go-plus</h4><ul>
<li><a href="https://atom.io/packages/go-plus" target="_blank" rel="external">https://atom.io/packages/go-plus</a></li>
</ul>
<p>这个插件提供了Atom中几乎所有go语言开发的支持，包括&nbsp;tools, build flows, linters, vet 和 coverage tools。它还包含很多代码片段和一些其它特性。</p>
<p>在你的命令行中输入下面的命令来确保你安装了所有go tools：</p>
<p>go get -u golang.org/x/tools/cmd/…<br>go get -u github.com/golang/lint/golint</p>
<p>go-plus有非常多的特性，但我在开发时最喜欢的是它能够实时的给我反馈语法错误和编译错误。每当我保存一个文件，go-plus就会在后台运行你提前配置好的要执行的go tools，例如：go vet, go oracle, go build等等，然后将错误和警告在编辑器底部显示出来。这个功能非常赞，而且大大提升了开发速度。</p>
<p><img src="http://marcio.io/img/atom-go-plus-linter.png" alt="atom-go-plus-linter"></p>
<p>它同样能够在编辑器的对应行上显示该行的编译错误提示和错误信息，这样你就能很快的定位哪一行有错。错误和警告分别用红色和淡黄色做区分。</p>
<p><img src="http://marcio.io/img/atom-go-plus-gutter-errors.png" alt="atom-go-plus-gutter-errors"></p>
<h4 id="go-rename"><a href="#go-rename" class="headerlink" title="go-rename"></a>go-rename</h4><ul>
<li><a href="https://atom.io/packages/go-rename" target="_blank" rel="external">https://atom.io/packages/go-rename</a></li>
</ul>
<p>这个插件通过食用Go rename tool，提供非常智能和安全的 变量，方法和结构体重命名功能。当你选中一个目标时，你能够通过快捷键&nbsp;ALT-R&nbsp;很方便的初始化重命名对话框。</p>
<p>让Atom更像VIM</p>
<p>你可能想问我“那为什么不直接使用VIM呢？”情况是这样的，我确实有使用VIM一年多，但是我想尝试使用Atom，我很享受atom的体验，特别是我能够在atom上使用所有的VIM命令。</p>
<ul>
<li>vim-mode:&nbsp;<a href="https://atom.io/packages/vim-mode" target="_blank" rel="external">https://atom.io/packages/vim-mode</a></li>
<li>vim-surround:&nbsp;<a href="https://atom.io/packages/vim-surround" target="_blank" rel="external">https://atom.io/packages/vim-surround</a></li>
<li>last-cursor-position:&nbsp;<a href="https://atom.io/packages/last-cursor-position" target="_blank" rel="external">https://atom.io/packages/last-cursor-position</a></li>
</ul>
<h5 id="u5728_Keymap__u6587_u4EF6_u4E2D_u5B9A_u4E49_u4E00_u4E9B_u5FEB_u6377_u952E_uFF1A"><a href="#u5728_Keymap__u6587_u4EF6_u4E2D_u5B9A_u4E49_u4E00_u4E9B_u5FEB_u6377_u952E_uFF1A" class="headerlink" title="在 Keymap 文件中定义一些快捷键："></a>在 Keymap 文件中定义一些快捷键：</h5><p>&#39;atom-text-editor:not(mini).autocomplete-active&#39;:<br>  &#39;ctrl-p&#39;: &#39;core:move-up&#39;<br>  &#39;ctrl-n&#39;: &#39;core:move-down&#39;</p>
<p>&#39;.vim-mode.command-mode:not(.mini)&#39;:<br>  &#39;ctrl-f&#39;: &#39;core:page-down&#39;<br>  &#39;/&#39;: &#39;find-and-replace:show&#39;</p>
<p>还有一个VIM模块Easy-Motion上面没有说到，这是因为它和Atom 1.0不兼容，但是我相信很快就会有人来更新它或者在创建一个新版本。</p>
<h2 id="u81EA_u5B9A_u4E49atom_u7684TreeView"><a href="#u81EA_u5B9A_u4E49atom_u7684TreeView" class="headerlink" title="自定义atom的TreeView"></a>自定义atom的TreeView</h2><h4 id="file-icons"><a href="#file-icons" class="headerlink" title="file-icons"></a>file-icons</h4><ul>
<li><a href="https://atom.io/packages/file-icons" target="_blank" rel="external">https://atom.io/packages/file-icons</a></li>
</ul>
<p>我刚开始想这个插件能够让我的tree view色彩丰富，它提针对不同后缀的文件，文件夹供了大量的icon显示。然后我使用了一下它，发现它确实很酷。并且它能够让我很快的一扫就能找到我要找的文件。它还有些配置，可以让你选择显示哪些文件的icon等。</p>
<p>下面你可以看到如果你安装了file-icons插件后你的tree view会变成什么样。试试吧，我确定你会喜欢它的。</p>
<p><img src="http://marcio.io/img/file-icons.png" alt="file-icons"></p>
<h4 id="u5E94_u7528_u4E00_u4E9B_u81EA_u5B9A_u4E49CSS"><a href="#u5E94_u7528_u4E00_u4E9B_u81EA_u5B9A_u4E49CSS" class="headerlink" title="应用一些自定义CSS"></a>应用一些自定义CSS</h4><p>默认的TreeView行距有些过高，所以我想要修改css减少行间的padding。还有一个要修改的地方是，treeview的字体也要修改成我在编辑框中使用的字体，来保持样式的一致性。我通常使用Inconsolata<br> 。</p>
<p>// style the background color of the tree view<br>.tree-view {<br>    font-family: &quot;Inconsolata&quot;;<br>    font-size: 12px;<br>}</p>
<p>.list-group li:not(.list-nested-item),<br>.list-tree li:not(.list-nested-item),<br>.list-group li.list-nested-item &gt; .list-item,<br>.list-tree li.list-nested-item &gt; .list-item {<br>    line-height:18px;<br>}</p>
<p>.list-group .selected:before,<br>.list-tree .selected:before {<br>    height:18px;<br>}</p>
<p>.list-tree.has-collapsable-children .list-nested-item &gt; .list-tree &gt; li,<br>.list-tree.has-collapsable-children .list-nested-item &gt; .list-group &gt; li {<br>    padding-left:12px;<br>}</p>
<h3 id="u4EE3_u7801_u7247_u6BB5_28Code_Snippets_29"><a href="#u4EE3_u7801_u7247_u6BB5_28Code_Snippets_29" class="headerlink" title="代码片段(Code Snippets)"></a>代码片段(Code Snippets)</h3><p>大部分流行的编辑器和IDE都会使用code-completion针对不同语言的特定关键字自动补全代码。这样通常能够包含最常用的代码，但是离真正的补全还差一截。</p>
<p>但是Atom允许你在snippets.cson文件中创建自己的代码片段仓库。在Atom的菜单栏可以打开这个文件，然后你就可以创建自己的代码片段库了。</p>
<p>你需要使用.source.go&nbsp;作为scope，这样这个片段就只会在你编辑go文件时提示你了。</p>
<p>下面是我最近添加的一些代码片段：</p>
<p>&#39;.source.go&#39;:<br>    &#39;return nil and error&#39;:<br>      &#39;prefix&#39;: &#39;rne&#39;<br>      &#39;body&#39;: &#39;return nil, err&#39;</p>
<pre><code>&amp;#39;return false and error&amp;#39;:
  &amp;#39;prefix&amp;#39;: &amp;#39;rfe&amp;#39;
  &amp;#39;body&amp;#39;: &amp;#39;return false, err&amp;#39;

&amp;#39;Return True and Nil&amp;#39;:
  &amp;#39;prefix&amp;#39;: &amp;#39;rte&amp;#39;
  &amp;#39;body&amp;#39;: &amp;#39;return true, nil&amp;#39;

&amp;#39;Import logrus&amp;#39;:
  &amp;#39;prefix&amp;#39;: &amp;#39;logrus&amp;#39;
  &amp;#39;body&amp;#39;: &amp;#39;log &amp;quot;github.com/Sirupsen/logrus&amp;quot;&amp;#39;
</code></pre><p>一旦你创建好代码片段，你立马就能在编辑器中使用。我非常喜欢这个功能，他能让我编码速度飞快。</p>
<p><img src="http://marcio.io/img/atom-complete-snippets.png" alt="atom-complete-snippets"></p>
<h3 id="Dash"><a href="#Dash" class="headerlink" title="Dash"></a>Dash</h3><p>Dash是一个Mac OS X下的非常棒的商业软件，它能够让你在离线模式下实时访问150&#43;的API 文档。我在做Ruby开发时使用了几年时间，现在做go开发同样适用它。</p>
<p>了解Dash：&nbsp;<a href="https://kapeli.com/dash" target="_blank" rel="external">https://kapeli.com/dash</a></p>
<p><img src="http://marcio.io/img/atom-dash.png" alt="atom-dash"></p>
<p>有一个Atom插件能够让你通过快捷键<code>CTRL-H</code>&nbsp;直接跳转动dash，这样查询选中方法的方法定义文档就非常方便了。</p>
<h4 id="dash"><a href="#dash" class="headerlink" title="dash"></a>dash</h4><p><a href="https://atom.io/packages/dash" target="_blank" rel="external">https://atom.io/packages/dash</a></p>
<h2 id="u81EA_u5B9A_u4E49_u7F16_u8F91_u5668_u6837_u5F0F"><a href="#u81EA_u5B9A_u4E49_u7F16_u8F91_u5668_u6837_u5F0F" class="headerlink" title="自定义编辑器样式"></a>自定义编辑器样式</h2><p>Atom有一个相比其它编辑器非常大的优点是，它能够通过食用css完全的自定义编辑器UI。如果你对atom不满意，几乎atom所有方面都能够被你自己修改和提高。</p>
<p>改变 Symbol View 的样式</p>
<p>atom有一个让我很困扰的区域是原声的Symbols-View对话框，它的行太高了，并且不能很好的在查看窗口适应很多行显示。我更喜欢Sublime的显示方式，所以我把atom的symbol view的样式改成和sublime一样。</p>
<p>.symbols-view {<br>  &amp;.select-list ol.list-group li .primary-line,<br>  &amp;.select-list ol.list-group li .secondary-line {</p>
<pre><code>font-family: Inconsolata;
font-size: 14px;

// let lines wrap
text-overflow: initial;
white-space: initial;
overflow: initial;

// reduce line-height
line-height: 1.0em;
padding-top: .1em;
padding-bottom: .0em;

// make sure wrapped lines get padding
// padding-left: 21px;
&amp;amp;.icon:before {
  margin-left: -21px;
}

.character-match {
    color: rgb(200, 200, 10) !important;
}
</code></pre><p>  }<br>}</p>
<p>.symbols-view {<br>  &amp;.select-list ol.list-group li .secondary-line {<br>      float: right;<br>      margin-top: -12px;<br>      padding-top: 0em;<br>      padding-bottom: 0em;<br>      font-size: 12px;<br>      color: rgba(200, 200, 10, 0.8) !important;<br>  }<br>}</p>
<p>这是一个更精简的Symbol View，可以看到行高减少了，行数提示放在了右侧：</p>
<p><img src="http://marcio.io/img/atom-symbol-view-styles.png" alt="atom-symbol-view-styles"></p>
<h3 id="u81EA_u5B9A_u4E49_u884C_u9009_u4E2D_u6548_u679C"><a href="#u81EA_u5B9A_u4E49_u884C_u9009_u4E2D_u6548_u679C" class="headerlink" title="自定义行选中效果"></a>自定义行选中效果</h3><p>有个很有趣的插件叫 Hightlight-Line:</p>
<p><a href="https://atom.io/packages/highlight-line" target="_blank" rel="external">https://atom.io/packages/highlight-line</a></p>
<p>这个插件允许你修改选中行的样式。在我的例子中，我在选中行上下侧加上了黄色的虚线。我喜欢这样的样式，它能够让我很好的识别我所选中的区域。</p>
<p><img src="http://marcio.io/img/atom-highlight-selected.png" alt="atom-highlight-selected"></p>
<p>你可以将‘solid’替换为 ‘dashed’ 或者 ‘dotted’。</p>
<p>atom-text-editor::shadow {</p>
<pre><code>.line.highlight-line {
    background: rgba(255, 255, 255, 0.05) !important;
}

.line.highlight-line-multi-line-dashed-bottom {
    border-bottom-color: yellow !important;
}

.line.highlight-line-multi-line-dashed-top {
    border-top-color: yellow !important;
}
</code></pre><p>}</p>
<h2 id="u4E3AGo_u4EE3_u7801_u751F_u6210_Ctags"><a href="#u4E3AGo_u4EE3_u7801_u751F_u6210_Ctags" class="headerlink" title="为Go代码生成 Ctags"></a>为Go代码生成 Ctags</h2><p>自动补全在开发中是一个非常重要的功能，同时也让开发这非常困扰。它的提示必须非常好不然的话经常出现的不对的提示信息会非常的讨厌。当需要提示的时候却没有提示时更是烦上加烦。</p>
<p>有一个非常棒的插件叫&nbsp;<code>gotags</code>&nbsp;，它能够兼容ctags并且专为go设计。它将AST工具化，并且会解析Go的标准库，非常的智能。它比标准的ctags工具生成的ctags好太多。</p>
<ul>
<li>gotags:&nbsp;<a href="https://github.com/jstemmer/gotags" target="_blank" rel="external">https://github.com/jstemmer/gotags</a></li>
</ul>
<p>通过下面命令安装gotags</p>
<p>go get -u github.com/jstemmer/gotags</p>
<p>在你的源码目录下执行下面命令声称ctags：</p>
<p>gotags -tag-relative=true -R=true -sort=true -f=&quot;tags&quot; -fields=+l .</p>
<p>这将会在你的项目根目录下生成新的tags文件，让你的代码提示更加智能。</p>
<p><img src="http://marcio.io/img/atom-go-tags.png" alt="atom-go-tags"></p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>无论你是Sublime Text爱好者还是VIM粉丝，你都应该尝试使用一下1.0版本的atom。</p>
<p>特别是它还是一个在Github.com上的开源项目，项目非常活跃，并且社区增长的也非常快。</p>
<p>快试试吧！！</p>
<pre><code>    作者：sweetvvck 发表于2015/12/29 0:37:30 [原文链接](http://blog.csdn.net/sweetvvck/article/details/50333327)


阅读：237 评论：0 [查看评论](http://blog.csdn.net/sweetvvck/article/details/50333327#comments)
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>在我在Windows系统上开发的日子里，我使用IDE开发数年之久，例如Visual Basic IDE, Borland Delphi IDE, Visual C&#43;&#43; 和最后的Visual Studio；但当我在大约10年前转到Mac OS X下开发后，我放]]>
    </summary>
    
      <category term="atom" scheme="http://sweetvvck.github.io/tags/atom/"/>
    
      <category term="golang" scheme="http://sweetvvck.github.io/tags/golang/"/>
    
      <category term="Editor" scheme="http://sweetvvck.github.io/categories/Editor/"/>
    
      <category term="Language" scheme="http://sweetvvck.github.io/categories/Editor/Language/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[原]Gitflow实践]]></title>
    <link href="http://sweetvvck.github.io/2015/12/16/%E5%8E%9F-Gitflow%E5%AE%9E%E8%B7%B5/"/>
    <id>http://sweetvvck.github.io/2015/12/16/原-Gitflow实践/</id>
    <published>2015-12-15T17:14:03.000Z</published>
    <updated>2016-01-25T20:07:08.000Z</updated>
    <content type="html"><![CDATA[<p>转载请注明出处：<a href="http://blog.csdn.net/sweetvvck/article/details/50245147" target="_blank" rel="external">Gitflow实践</a></p>
<h1 id="Gitflow_u5B9E_u8DF5"><a href="#Gitflow_u5B9E_u8DF5" class="headerlink" title="Gitflow实践"></a>Gitflow实践</h1><p>这两周在和别的团队的两个小伙伴开发新项目，他们团队刚刚成立不久，各种规范还没跟上，于是我便各种安利我们团队的工作流，其中代码管理方面我就推荐他们使用gitflow。在给他们讲gitflow的过程中我发现他们不是很理解这种工作方式，或者说不太明白为什么要这样做，为了加深自己对gitflow的理解我觉得有必要记录一下，也让正在学习使用gitflow的同学们有个初步的了解。</p>
<hr>
<h2 id="Git_u5DE5_u4F5C_u6D41"><a href="#Git_u5DE5_u4F5C_u6D41" class="headerlink" title="Git工作流"></a>Git工作流</h2><p>现在越来越多的项目开始使用git做为版本控制工具，我对版本控制工具的最初印象是：能把代码提交到远端让大家一起协作，能开分支，能回滚代码，能看到每次提交的修改等。不过git命令具体如何使用不是本文的重点(熟悉git可以参考<a href="http://blog.csdn.net/sweetvvck/article/details/38414713" target="_blank" rel="external"> GIT基本概念和用法总结</a> 和<a href="http://blog.csdn.net/sweetvvck/article/details/38548985" target="_blank" rel="external"> git - 简易指南</a>)，本文的重点是在项目中如何使用git来高效清晰的处理开发协作，版本控制。Git的工作流其实就是对git在项目上的一个完整的使用方式归纳总结，比较流行的git工作流有：Gitflow Workflow, Centralized Workflow, Feature Branch Workflow, Forking Workflow。</p>
<p>值得注意的是，这些workflow只是作为如何更好的使用git的指导方针，而非<code>&quot;铁律&quot;</code>，我们也可以根据具体项目来组合使用不同的workflow。本文重点讲解Gitflow Workflow，有想了解其他git工作流的可以参考这篇文章：<a href="https://www.atlassian.com/git/tutorials/comparing-workflows" target="_blank" rel="external">Comparing Workflows</a>。</p>
<h2 id="Gitflow_workflow"><a href="#Gitflow_workflow" class="headerlink" title="Gitflow workflow"></a>Gitflow workflow</h2><p>Gitflow从功能开发到正式发布再到热修复等都有相应的策略管理，可以说是非常的完善，对于大型的项目也能够很好的管理。</p>
<h3 id="Gitflow__u5206_u652F"><a href="#Gitflow__u5206_u652F" class="headerlink" title="Gitflow 分支"></a>Gitflow 分支</h3><p>Gitflow使用不同的分支表达了它在工作流中的不同概念：</p>
<ul>
<li><strong>Master分支存放所有正式发布的版本，可以作为项目历史版本记录分支</strong></li>
<li><strong>Develop分支为主开发分支</strong></li>
<li><strong>Feature/xx分支为新功能分支，feature分支都是基于develop创建的，开发完成后会合并到develop分支上</strong></li>
<li><strong>Release分支基于最新develop分支创建，当新功能足够发布一个新版本(或者接近新版本发布的截止日期)，从develop分支创建一个release分支作为新版本的起点，开发完成后合并到master并打上版本号，同时也合并到develop，更新最新开发分支</strong></li>
<li><strong>Hotfix分支基于Master分支创建，对线上版本的bug进行修复，完成后直接合并到master分支和develop分支</strong></li>
</ul>
<p><img src="https://www.atlassian.com/git/images/tutorials/collaborating/comparing-workflows/gitflow-workflow/05.svg" alt="Gitflow分支"></p>
<h3 id="Gitflow_u5177_u4F53_u6D41_u7A0B"><a href="#Gitflow_u5177_u4F53_u6D41_u7A0B" class="headerlink" title="Gitflow具体流程"></a>Gitflow具体流程</h3><p>上文提到，从项目启动到发布版本都能够使用gitflow管理，具体如何管理，下 main这张图表达的很清楚：</p>
<p><img src="http://nvie.com/img/git-model@2x.png" alt="这里写图片描述"></p>
<p>从上图可以看到，随着时间的推移：</p>
<ol>
<li>项目启动时只有master分支(图最右侧，蓝色)，开发到0.1版本时给它打上tag:0.1；</li>
<li>接着创建了develop分支(黄色)开始接下来的开发；</li>
<li>在开发的过程中发现0.1版本有bug，基于master分支0.1版本创建hotfix分支修复bug，修复完成后同时合并到develop分支和master分支，并在master分支上打上版本号；</li>
<li>团队成员创建不同的feature分支(红色)开发下个版本的新功能，完成后合并到develop分支上；</li>
<li>当feature完成情况按照项目计划能够发布新版本1.0时，创建release分支，对该分支进行测试修复，通过测试后release分支将被同时合并到develop分支和master分支，同时master分支打上相应版本号；</li>
<li>继续上面的流程</li>
</ol>
<p>⚠️注意：feature与其它分支互不影响，不必要在发布新版本前完成所有feature，发布版本时也可以有feature开发同时进行。</p>
<h3 id="u4F7F_u7528"><a href="#u4F7F_u7528" class="headerlink" title="使用"></a>使用</h3><p>Gitflow workflow是由<a href="http://nvie.com/" target="_blank" rel="external">Vincent Driessen</a> 提出来的，要实现上述的工作流程需要使用到他创建的命令行工具<a href="https://github.com/nvie/gitflow" target="_blank" rel="external">git-flow</a> 具体如何使用请参考<a href="http://danielkummer.github.io/git-flow-cheatsheet/index.zh_CN.html" target="_blank" rel="external">git-flow 备忘清单</a>。</p>
<p>另外，有一款git客户端软件<a href="https://www.sourcetreeapp.com/" target="_blank" rel="external">sourcetree</a> 集成了gitflow命令，提供了非常便捷的方式使用gitflow流程。</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>熟练掌握和Gitflow workflow能够团队内项目协作开发流程更加规范化，更加清晰化，但是不必过于拘泥于其定义的流程，这类workflow只是使用git的指导方针，目的都是高效的使用git协作。</p>
<h2 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="http://nvie.com/posts/a-successful-git-branching-model/" target="_blank" rel="external">A successful Git branching model</a></li>
<li><a href="https://www.atlassian.com/git/tutorials/comparing-workflows" target="_blank" rel="external">Comparing Workflows</a></li>
<li><p><a href="http://danielkummer.github.io/git-flow-cheatsheet/index.zh_CN.html" target="_blank" rel="external">git-flow 备忘清单</a></p>
<pre><code>作者：sweetvvck 发表于2015/12/16 1:14:03 [原文链接](http://blog.csdn.net/sweetvvck/article/details/50245147)
</code></pre></li>
</ol>
<pre><code>阅读：508 评论：0 [查看评论](http://blog.csdn.net/sweetvvck/article/details/50245147#comments)
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>转载请注明出处：<a href="http://blog.csdn.net/sweetvvck/article/details/50245147" target="_blank" rel="external">Gitflow实践</a></p>
<h1 id="Gitflo]]>
    </summary>
    
      <category term="Git" scheme="http://sweetvvck.github.io/tags/Git/"/>
    
      <category term="Gitflow" scheme="http://sweetvvck.github.io/tags/Gitflow/"/>
    
      <category term="Git" scheme="http://sweetvvck.github.io/categories/Git/"/>
    
      <category term="项目管理" scheme="http://sweetvvck.github.io/categories/Git/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[原]Koa中间件方式实现API的Undo功能]]></title>
    <link href="http://sweetvvck.github.io/2015/05/08/%E5%8E%9F-Koa%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0API%E7%9A%84Undo%E5%8A%9F%E8%83%BD/"/>
    <id>http://sweetvvck.github.io/2015/05/08/原-Koa中间件方式实现API的Undo功能/</id>
    <published>2015-05-08T15:12:05.000Z</published>
    <updated>2016-01-25T20:07:11.000Z</updated>
    <content type="html"><![CDATA[<h1 id="Koa_u4E2D_u95F4_u4EF6_u65B9_u5F0F_u5B9E_u73B0API_u7684Undo_u529F_u80FD"><a href="#Koa_u4E2D_u95F4_u4EF6_u65B9_u5F0F_u5B9E_u73B0API_u7684Undo_u529F_u80FD" class="headerlink" title="Koa中间件方式实现API的Undo功能"></a>Koa中间件方式实现API的Undo功能</h1><h2 id="API_u7684Undo_u529F_u80FD"><a href="#API_u7684Undo_u529F_u80FD" class="headerlink" title="API的Undo功能"></a>API的Undo功能</h2><p>使用过Gmail或者163邮箱的同学会经常看到，当对邮件进行一些操作时会出现一个类似Toast的提示（大致意思是：操作已经完成，是否撤销）如下图所示：</p>
<p><img src="http://img.blog.csdn.net/20150508220504487" alt=""></p>
<p><img src="http://img.blog.csdn.net/20150508220843186" alt=""></p>
<p>当点击撤销时，之前执行的操作能够被还原，这种设计对于用户的误操作是一个非常棒的补救方案。</p>
<p>之前听过一句有关交互设计的话说的非常好，不要在用户每做一步操作时弹出Alert让用户选择”确定”或者”取消”，更好的做法是执行操作，然后让用户能够Undo。</p>
<h2 id="u5B9E_u73B0API_Undo_u7684_u65B9_u6848"><a href="#u5B9E_u73B0API_Undo_u7684_u65B9_u6848" class="headerlink" title="实现API Undo的方案"></a>实现API Undo的方案</h2><p>其实Undo是很老的技术，在编辑器中无处不在，只是在API设计中使用的还比较少。最近一直在使用Node开发，因此想使用Node实现一下API的Undo。</p>
<p>首先要明确几点：</p>
<ul>
<li>并不是所有的API都需要Undo，比如获取数据的接口就完全没有Undo的必要（而且逻辑上也没办法做）</li>
<li>只能针对用户最后一次操作进行Undo</li>
<li>Undo是在用户维度的，用户不能Undo其他用户的操作</li>
</ul>
<h3 id="u4F20_u7EDF_u65B9_u6848_28Plan_A_29_uFF1A"><a href="#u4F20_u7EDF_u65B9_u6848_28Plan_A_29_uFF1A" class="headerlink" title="传统方案(Plan A)："></a>传统方案(Plan A)：</h3><ul>
<li>需要对所有需要Undo的接口提供Undo逻辑;</li>
<li>当用户要Undo最近一次操作时需要调用这个方法（常常会涉及数据库操作）。</li>
</ul>
<h3 id="u65B0_u65B9_u6848_28Plan_B_29_uFF1A"><a href="#u65B0_u65B9_u6848_28Plan_B_29_uFF1A" class="headerlink" title="新方案(Plan B)："></a>新方案(Plan B)：</h3><ul>
<li>以中间件(类似Java中的拦截器)方式提供Undo服务</li>
<li>对需要Undo的API逻辑放入指定队列延迟执行</li>
<li>调用Undo接口时将最近一次操作从延迟执行的队列中移除</li>
<li>调用其他接口是立即执行延迟队列中的逻辑</li>
</ul>
<h2 id="u65B9_u6848_u5BF9_u6BD4"><a href="#u65B9_u6848_u5BF9_u6BD4" class="headerlink" title="方案对比"></a>方案对比</h2><h3 id="u4F18_u70B9_uFF1A"><a href="#u4F18_u70B9_uFF1A" class="headerlink" title="优点："></a>优点：</h3><h4 id="u65B9_u6848A_3A"><a href="#u65B9_u6848A_3A" class="headerlink" title="方案A:"></a>方案A:</h4><ul>
<li>可以对任意接口进行undo操作；</li>
<li>逻辑简单，undo时无需操作数据库；</li>
</ul>
<h4 id="u65B9_u6848B_3A"><a href="#u65B9_u6848B_3A" class="headerlink" title="方案B:"></a>方案B:</h4><ul>
<li>操作真实反映到了数据库；</li>
<li>无需限制undo过期时间；</li>
</ul>
<h3 id="u7F3A_u70B9"><a href="#u7F3A_u70B9" class="headerlink" title="缺点"></a>缺点</h3><h4 id="u65B9_u6848A_3A-1"><a href="#u65B9_u6848A_3A-1" class="headerlink" title="方案A:"></a>方案A:</h4><ul>
<li>访问可undo接口后，再访问非undo接口，之前逻辑不能undo；</li>
</ul>
<h4 id="u65B9_u6848B_3A-1"><a href="#u65B9_u6848B_3A-1" class="headerlink" title="方案B:"></a>方案B:</h4><ul>
<li>逻辑较为复杂，undo需要做数据库操作；</li>
<li>并非所有操作都能够undo；</li>
</ul>
<h2 id="u65B9_u6848_u5B9E_u73B0"><a href="#u65B9_u6848_u5B9E_u73B0" class="headerlink" title="方案实现"></a>方案实现</h2><p>通过上边的方案对比，我发现Plan A更简单、灵活，因此决定实现Plan A。</p>
<p>使用过Koa的通许都知道，koa的中间件非常强大（类似Java web开发中的拦截器），它能够拦截所有请求并执行一些逻辑，例如计算API请求到响应时长等，这里我们就可以使用这个特性将需要Undo的API延迟执行。</p>
<p>首先我们要设置Undo的超时时间，以及那些API需要Undo：</p>
<pre><code>var apis = (options || {}).apis;
var expired = (options || {}).expired || 3000;`

还要明确当前访问API的用户：

`/**
 * `x-identify-key` is used to identify the user of this request,
 * one user can not undo another`s request.
 */

var user = context.header[&apos;x-identify-key&apos;];`

然后延迟执行API逻辑：

`var undo = yield delayNext(user, expired, context);`

如果用户没有调用Undo接口，则执行逻辑，否则返回’undo’:

`if (!undo) { return yield next; }
this.body = &apos;undo&apos;;`

如果用户调用Undo接口，移除延迟执行的逻辑；调用其他接口则立即执行延迟的逻辑：

`clearTimeout(undoObj.timeoutId);
if (path === &apos;/undo&apos; &amp;amp;&amp;amp; method === &apos;POST&apos;) {
  undoObj.delayFn.call(undoObj.context, true);
  context.body = &apos;done&apos;;
  return;
} else if (undoObj.delayFn) {
  undoObj.delayFn.call(undoObj.context, false);
}`

具体实现逻辑大概就这些，完整代码如下：

`
/**
 * Store users&apos; undo context
 *
 * @type {Object}
 */
var undos = {};

/**
 * Expose `undo`
 *
 * @param {Object} options Config object for undo
 * @example
 * {
 *   expired: 3000
 * }
 */
module.exports = function (options) {
  var apis = (options || {}).apis;
  var expired = (options || {}).expired || 3000;

  return function* (next) {
    var context = this;
    var path = context.path;
    var needUndo = false;

    if (apis &amp;amp;&amp;amp; Array.isArray(apis) &amp;amp;&amp;amp; apis.length) {
      needUndo = apis.filter(function (api) {
        return path === api;
      }).length;
    }

    if (!needUndo &amp;amp;&amp;amp; path !== &apos;/undo&apos;) { return yield next; }

    var method = context.method;
    /**
     * Can not undo get request.
     */
    if (method === &apos;GET&apos;) { return yield next; }
    /**
     * &apos;x-identify-key&apos; is used to identify the user of this request,
     * one user can not undo another&apos;s request.
     */
    var user = context.header[&apos;x-identify-key&apos;];
    if (!user) { return yield next; }

    var undoObj = undos[user];
    if (undoObj) {
      clearTimeout(undoObj.timeoutId);
      if (path === &apos;/undo&apos; &amp;amp;&amp;amp; method === &apos;POST&apos;) {
        undoObj.delayFn.call(undoObj.context, true);
        context.body = &apos;done&apos;;
        return;
      } else if (undoObj.delayFn) {
        undoObj.delayFn.call(undoObj.context, false);
      }
    }
    var undo = yield delayNext(user, expired, context);
    if (!undo) { return yield next; }
    this.body = &apos;undo&apos;;
  };
};

/**
 * Block the logic for specified ms.
 *
 * @param {String} user The user&apos;s identity
 * @param {String} expired The expired ms
 * @param {Object} context The koa context object
 * @api private
 */
function delayNext(user, expired, context) {
  return function (callback) {
    var delayFn = function (undo) {
      delete undos[user];
      callback(null, undo);
    };
    var timeoutId = setTimeout(delayFn, expired);
    undos[user] = {
      timeoutId: timeoutId,
      delayFn: delayFn,
      context: context
    };
  };
}
</code></pre><h2 id="u9879_u76EE_u76F8_u5173"><a href="#u9879_u76EE_u76F8_u5173" class="headerlink" title="项目相关"></a>项目相关</h2><p>目前此项目托管在Github上，<a href="https://github.com/sweetvvck/koa-undo" target="_blank" rel="external">https://github.com/sweetvvck/koa-undo</a>，koa-undo具体使用方法项目主页有详细介绍，感兴趣的同学欢迎提Issue、PR；同时koa-undo也发布到了Npm上，<a href="https://www.npmjs.com/package/koa-undo" target="_blank" rel="external">https://www.npmjs.com/package/koa-undo</a> ，欢迎大家使用。</p>
<pre><code>    作者：sweetvvck 发表于2015/5/8 23:12:05 [原文链接](http://blog.csdn.net/sweetvvck/article/details/45585997)


阅读：730 评论：0 [查看评论](http://blog.csdn.net/sweetvvck/article/details/45585997#comments)
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Koa_u4E2D_u95F4_u4EF6_u65B9_u5F0F_u5B9E_u73B0API_u7684Undo_u529F_u80FD"><a href="#Koa_u4E2D_u95F4_u4EF6_u65B9_u5F0F_u5B9E_u73B0API_u]]>
    </summary>
    
      <category term="api" scheme="http://sweetvvck.github.io/tags/api/"/>
    
      <category term="koa" scheme="http://sweetvvck.github.io/tags/koa/"/>
    
      <category term="undo" scheme="http://sweetvvck.github.io/tags/undo/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[译]Twemproxy来自Twitter的Redis代理]]></title>
    <link href="http://sweetvvck.github.io/2014/12/31/%E8%AF%91-Twemproxy%E6%9D%A5%E8%87%AATwitter%E7%9A%84Redis%E4%BB%A3%E7%90%86/"/>
    <id>http://sweetvvck.github.io/2014/12/31/译-Twemproxy来自Twitter的Redis代理/</id>
    <published>2014-12-31T14:35:41.000Z</published>
    <updated>2016-01-25T19:47:11.000Z</updated>
    <content type="html"><![CDATA[<p>在大量用户大规模使用大型Redis节点的时候，目前从项目本身来看Redis基本上可以说是一个单例的业务。</p>
<p>关于这个项目的分布式我有一个很大的想法，在这个想法下，我不需要去对多线程版本的Redis做任何评估：在这个角度上对我来说，一个核就像是一台计算机，所以在多核上扩展就相当于分布在计算机之间的集群。多实例是一个无共享的架构。如果我们找到一个可用的方式来分片，那么所有事情就合理了。 :-)</p>
<p>这也是为什么集群会成为Redis在2013年的焦点，并且，最终Redis 2.6的发布表现出了很好的稳定性和成熟度，现在正是时候来关注Redis Cluster, Redis Sentinel, 以及一些其它期待已久的改进。</p>
<p>然而现实状况是，Redis Cluster目前仍然没有发布，正式版还需要几个月的工作。但是我们的用户已经需要将数据分片到不同的实例上来做负载均衡，更重要的是为数据获得更大的内存存储。</p>
<p>目前保底的结局方案是客户端分片。客户端分片有很多好处，例如：在客户端和节点之间没有中间层，这就意味着它是一个扩展性很好的设置（主要是线性扩展）。然而要稳定的实现（客户端分片）需要进行一些优化，需要一个同步客户端配置的方式，也需要客户端支持一致性哈希或其它分区算法。</p>
<p>有一个重大消息来自Twitter，世界最大的Redis集群之一部署在Twitter用于为用户提供时间轴数据。所以毫不奇怪这篇文章讨论的项目来自Twitter Open Source部门。</p>
<h2 id="Twemproxy"><a href="#Twemproxy" class="headerlink" title="Twemproxy"></a>Twemproxy</h2><p>Twemproxy是一个快速的单线程代理程序，支持Memcached ASCII协议和更新的Redis协议：&nbsp;</p>
<p>它全部用C写成，使用Apache 2.0 License授权。&nbsp;<br>项目在Linux上可以工作，而在OSX上无法编译，因为它依赖了epoll API.<br>我的测试环境为Ubuntu 12.04桌面版。&nbsp;</p>
<p>好吧，闲话少叙。twemproxy到底做了什么？（注：我将关注Redis到部分，但是该项目也可以对memcached做相同到事情）&nbsp;</p>
<p>1) 在客户端和众多Redis实例间作为代理。&nbsp;<br>2) 在配置的Redis实例之间进行自动到数据分片。&nbsp;<br>3) 支持一致性哈希，支持不同到策略和哈希方法。&nbsp;</p>
<p>Twemproxy最了不起的地方就在于它能在节点失败的时候卸载它，然后可以在一段时间以后重新尝试（随即）连接，又或者可以严&#26684;按照配置文件中写的键与服务器之间对应关系进行连接。这意味着Twemproxy能胜任把Redis当做数据存储（不能容忍节点未命中）的场景，也能够胜任当做缓存来使用，那些允许（它意味着少量，不是说低质量）未命中且高可用的场景。<br>总结来说就是：如果你能容忍未命中，那么当有节点失败你的数据也许会存储到其他节点，所以它会是弱一致性的。另一方面，如果你不能容忍未命中，那么你需要一个拥有高可用的实例的方案，例如使用Redis监控的失败自动切换功能。</p>
<p>安装 &nbsp;<br>—&nbsp;</p>
<p>在深入项目的更多特性之前，有一个好消息，它在Linux上非常容易构建。好吧，没有Redis那么简单，但是……你仅仅需要简单按照下面的几步操作：<br>apt-get install automake&nbsp;<br>apt-get install libtool&nbsp;<br>git clone git://github.com/twitter/twemproxy.git&nbsp;<br>cd twemproxy&nbsp;<br>autoreconf -fvi&nbsp;<br>./configure –enable-debug=log&nbsp;<br>make&nbsp;<br>src/nutcracker -h&nbsp;</p>
<p>它的配置也非常简单，在项目的github页面上有足够的文档可以让你有一个平滑的初体验。我使用了如下的配置：<br>redis1:&nbsp;<br>&nbsp; listen: 0.0.0.0:9999&nbsp;<br>&nbsp; redis: true&nbsp;<br>&nbsp; hash: fnv1a_64&nbsp;<br>&nbsp; distribution: ketama&nbsp;<br>&nbsp; auto_eject_hosts: true&nbsp;<br>&nbsp; timeout: 400&nbsp;<br>&nbsp; server_retry_timeout: 2000&nbsp;<br>&nbsp; server_failure_limit: 1&nbsp;<br>&nbsp; servers:&nbsp;<br>&nbsp; &nbsp;- 127.0.0.1:6379:1&nbsp;<br>&nbsp; &nbsp;- 127.0.0.1:6380:1&nbsp;<br>&nbsp; &nbsp;- 127.0.0.1:6381:1&nbsp;<br>&nbsp; &nbsp;- 127.0.0.1:6382:1&nbsp;</p>
<p>redis2:&nbsp;<br>&nbsp; listen: 0.0.0.0:10000&nbsp;<br>&nbsp; redis: true&nbsp;<br>&nbsp; hash: fnv1a_64&nbsp;<br>&nbsp; distribution: ketama&nbsp;<br>&nbsp; auto_eject_hosts: false&nbsp;<br>&nbsp; timeout: 400&nbsp;<br>&nbsp; servers:&nbsp;<br>&nbsp; &nbsp;- 127.0.0.1:6379:1&nbsp;<br>&nbsp; &nbsp;- 127.0.0.1:6380:1&nbsp;<br>&nbsp; &nbsp;- 127.0.0.1:6381:1&nbsp;<br>&nbsp; &nbsp;- 127.0.0.1:6382:1&nbsp;</p>
<p>第一个集群配置为（故障时）节点自动排除，第二个集群则在所有实例上配置了静态映射。&nbsp;</p>
<p>有趣的是，针对同一组服务器你能同时有多个部署。然而在生产环境更适合使用多个示例以利用多核的能力。</p>
<p>单点失效？&nbsp;<br>—&nbsp;</p>
<p>还有另一件有趣的事情，使用这个部署并不意味着有单点失效问题，你可以通过运行多套twemproxy，让你的客户端连接到第一个可用的实例。&nbsp;</p>
<p>通过使用twemproxy你基本上把分片逻辑和客户端进行了分离。在这种情况下，一个基本的客户端就可以实现目的，分片将完全由代理来处理。<br>这是一个直接而安全的方法，个人观点。<br>现在Redis Cluster还不成熟，twemproxy是大多数希望利用Redis集群的用户的好方法。也不要太激动，先看看这种方法的限制 ;)</p>
<h2 id="u4E0D_u8DB3"><a href="#u4E0D_u8DB3" class="headerlink" title="不足"></a>不足</h2><p>我认为Twemproxy没有支持批量操作的命令和事物是对的。当然，AFAIK甚至比Redis cluster更严&#26684;，反而它对于相同的键允许批量操作。<br>但是恕我直言按照这种方式，分散的集群带来分散的效率，并且将这个挑战带给了早期的用户，而且花费了大量的资源，从大量的实例中汇总数据，得到仅仅是“能用”的结果，而且你将很快开始有严重的负载问题，因为你有太多的时间花费在数据的传输上。</p>
<p>可是有一些批量操作命令还是支持了的。MGET和DEL是处理的非常好的。有趣的是MGET命令在不同的服务器之间切分请求并且返回一个结果。这一点相当酷，也许我以后不能有更好的性能（看以后的吧）。<br>无论如何，批量操作和事物的不支持的现状意味着Twemproxy不适用于每个人，特别像Redis cluster本身。特别是它显然不支持EVAL（我认为他们应该支持它！它是多通用的，EVAL被设计可以在代理中工作，是因为键的名字已经明确了）。</p>
<h2 id="u6709_u5F85_u6539_u8FDB_u7684_u5730_u65B9"><a href="#u6709_u5F85_u6539_u8FDB_u7684_u5730_u65B9" class="headerlink" title="有待改进的地方"></a>有待改进的地方</h2><p>错误报告机制并不稳定，发送一个Redis不支持的命令会导致连接被关闭。比如从redis-cli只发送一个‘GET‘并不会报&quot;参数个数不正确”的错误，只会导致连接被挂起。<br>总体看来，服务器返回的其它错误都可以准确的传给客户端：<br>redis metal: 10000 &gt; get list<br>(错误)类型操作错误，键匹配了错误的&#20540;类型<br>另外一个我想要看到的特性是对自动故障恢复的支持。有很多种替代方案：<br>1) twemproxy已经能够监控实例错误信息、错误的数量、在检测出足够多的错误的情况下断开节点。但是很遗憾twemproxy不能够拿从节点作为替代方案，这样就可以发送一个SLAVE OFNOONE命令来弃用备用节点，而不用只是断开错误节点。这种情况下twemproxy才是一个具有高可用性的解决方案。<br>2) 或者，我希望twemproxy能够与Redis Sentinel一起协同工作，定期检查Sentinel配置，如果出现故障则更新服务端配置<br>3) 另外一种替代方案是提供一种热配置twemproxy的方式，一旦节点出故障，Redis Sentinel就能够切换ASAP代理配置<br>有很多种替代方案，总体来说，如果能够提供对HA(高可用性)的底层支持就非常棒了。</p>
<h2 id="u6027_u80FD_26nbsp_3B"><a href="#u6027_u80FD_26nbsp_3B" class="headerlink" title="性能&nbsp;"></a>性能&nbsp;</h2><p>Twemproxy很快，真的很快，接近直接与Redis通讯的速度。我敢说你用的话最多损失20%的性能。<br>我对性能唯一的意见是可以有更高效的方法把IMHO MGET命令分发到实例之间<br>如果twemproxy与所有Redis实例的延迟很相&#20284;的话(很有可能)，在MGETs命令在同一时间发出的情况下，twemproxy很有可能会在同一时间接收到所有节点的命令，所以我希望看到的是当我在所有实例上运行MGET命令的时候，发送的数量和twemproxy接收到的数量是一致的，但是实际上twemproxy在一秒内只接收到了50%的MGET命令。也许是时候重构twemproxy的应答模块了。</p>
<h2 id="u7ED3_u8BBA"><a href="#u7ED3_u8BBA" class="headerlink" title="结论"></a>结论</h2><p>这是个伟大的项目，鉴于Redis Cluster还未发布，我强烈建议有需求的Redis用户试一下Twemproxy<br>我正打算将它链接到Redis项目网站上，因为我认为Twitter的伙计已经用他们的项目为Redis做了不小的贡献，所以…<br>这是Twitter赢得荣誉！</p>
<pre><code>    作者：sweetvvck 发表于2014/12/31 22:35:41 [原文链接](http://blog.csdn.net/sweetvvck/article/details/42302675)


阅读：1373 评论：0 [查看评论](http://blog.csdn.net/sweetvvck/article/details/42302675#comments)
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>在大量用户大规模使用大型Redis节点的时候，目前从项目本身来看Redis基本上可以说是一个单例的业务。</p>
<p>关于这个项目的分布式我有一个很大的想法，在这个想法下，我不需要去对多线程版本的Redis做任何评估：在这个角度上对我来说，一个核就像是一台计算机，所以在多]]>
    </summary>
    
      <category term="Redis" scheme="http://sweetvvck.github.io/tags/Redis/"/>
    
      <category term="Twemproxy" scheme="http://sweetvvck.github.io/tags/Twemproxy/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[原]设计高可用Web服务]]></title>
    <link href="http://sweetvvck.github.io/2014/12/28/%E5%8E%9F-%E8%AE%BE%E8%AE%A1%E9%AB%98%E5%8F%AF%E7%94%A8Web%E6%9C%8D%E5%8A%A1/"/>
    <id>http://sweetvvck.github.io/2014/12/28/原-设计高可用Web服务/</id>
    <published>2014-12-28T15:22:03.000Z</published>
    <updated>2016-01-25T19:47:18.000Z</updated>
    <content type="html"><![CDATA[<p>转载请注明出处：<a href="http://blog.csdn.net/sweetvvck/article/details/42222429" target="_blank" rel="external">设计高可用Web服务</a></p>
<p>高可用的设计可以说是web服务架构的目标，如果服务达不到高可用，万一出现故障将会对产品带来重大的负面影响。高可用的架构就是能够让服务在任何情况下都能正常响应，比如双十一的淘宝，面对激增的洪峰照样正常工作；而聚美三周年时服务器的宕机恰好是高可用的反例。</p>
<p><strong>什么是高可用</strong></p>
<ul>
<li>可用性：在应用工作周期中可用时间的百分比</li>
<li>不可用：应用无法访问，服务中断应用访问非常缓慢</li>
<li>高可用：服务一直正常可用，快速响应</li>
</ul>
<p><strong>Tags</strong></p>
<ul>
<li><p>SPoF：单点故障</p>
</li>
<li><p>Failover：故障转移</p>
</li>
<li>Disaster Recovery：灾难恢复</li>
<li>Load Balancing：负载均衡</li>
<li>……</li>
</ul>
<p>说到高可用，我们常常会提到上面这些标签，也是设计高可用服务需要考虑和解决的点。下面我们来看看如何设计一个高可用的架构，如何来解决上面的问题，实现高可用。</p>
<p><strong>如何设计</strong></p>
<p>在服务架构时，我们不能相信任何一个环节是100%没问题的，服务的每个层级，使用的数据库，缓存，甚至是服务器本身，服务器放置的机房这些硬件环节都不能完全相信。如果我们假设每个环节都有可能出现问题，在每个环节出现问题时都有方案应对，那么这样设计出来的服务一定就是高可用的了。上面这种考虑问题的方式我们称为“假定失效原则”，在设计服务架构时，我们就要坚持这一原则。</p>
<p>下面我以一个例子从浅入深的为大家讲解如何设计高可用服务：</p>
<p>在服务搭建初期，其实并不需要考虑太多，目标是将服务快速搭建，完成功能，验证产品；我们的架构可能是这样的：</p>
<p><img src="http://img.blog.csdn.net/20141229004215515?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3dlZXR2dmNr/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br><a href="https://app.yinxiang.com/shard/s18/sh/92a8e772-0432-4c4f-bbdd-ba4a449bd9fe/83b1eea9519c0456?content=#" title="下载" target="_blank" rel="external"></a><a href="https://app.yinxiang.com/shard/s18/sh/92a8e772-0432-4c4f-bbdd-ba4a449bd9fe/83b1eea9519c0456?content=#" title="图片集" target="_blank" rel="external"></a></p>
<p>但是，与高可用的标准相比，这样的设计最大最直接的问题显而易见。我们可以看到整个架构就只有一个web&nbsp;server和一个数据库，那么要是它们之中任意一个无法访问，整个服务就瘫痪了；这样的故障，我们称之为SPoF—单点故障。</p>
<p>单点故障可难不倒我们，采用分布式架构，web server放置在不同的数据中心，同时数据库做主备或者复制集；这样就解决了单点故障，此时的架构应该是这样的：</p>
<p><img src="http://img.blog.csdn.net/20141229004231609?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3dlZXR2dmNr/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br><a href="https://app.yinxiang.com/shard/s18/sh/92a8e772-0432-4c4f-bbdd-ba4a449bd9fe/83b1eea9519c0456?content=#" title="下载" target="_blank" rel="external"></a><a href="https://app.yinxiang.com/shard/s18/sh/92a8e772-0432-4c4f-bbdd-ba4a449bd9fe/83b1eea9519c0456?content=#" title="图片集" target="_blank" rel="external"></a></p>
<p>在这样的架构中，我们将用户的请求通过一个代理（只能做简单的分发）分发到处于不同数据中心的web&nbsp;server上解决了单点故障。可是另一个问题又来了，如果其中一个数据中心的web server无法访问，虽然另一个web server能够正常工作，但是仍然会有部分请求发送到故障的机器上，整体来说仍然不能达到高可用。面对这样的问题，我们的第一反应是是否能够让请求不要再转发到故障的机器呢？</p>
<p>答案是肯定的，这种做法叫failover—故障转移，与failover经常一起出现的还有一种设计方案叫灾难恢复，它们常常一起使用。要达到的效果是，代理发现某台服务器无法访问，便不将请求发往这台机器，同时会启动另外一台机器，当这台机器完成初始化便将部分请求发往新的机器上。此时的架构应该是这样的：</p>
<p><img src="http://img.blog.csdn.net/20141229004242666?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3dlZXR2dmNr/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br><a href="https://app.yinxiang.com/shard/s18/sh/92a8e772-0432-4c4f-bbdd-ba4a449bd9fe/83b1eea9519c0456?content=#" title="下载" target="_blank" rel="external"></a><a href="https://app.yinxiang.com/shard/s18/sh/92a8e772-0432-4c4f-bbdd-ba4a449bd9fe/83b1eea9519c0456?content=#" title="图片集" target="_blank" rel="external"></a></p>
<p><img src="http://img.blog.csdn.net/20141229004301090?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3dlZXR2dmNr/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br><a href="https://app.yinxiang.com/shard/s18/sh/92a8e772-0432-4c4f-bbdd-ba4a449bd9fe/83b1eea9519c0456?content=#" title="下载" target="_blank" rel="external"></a><a href="https://app.yinxiang.com/shard/s18/sh/92a8e772-0432-4c4f-bbdd-ba4a449bd9fe/83b1eea9519c0456?content=#" title="图片集" target="_blank" rel="external"></a></p>
<p>通过上面的设计，我们离高可用又近了一步，但是仍然不能说是高可用的设计。试想，现在我们的服务都是多数据中心的了，而且能够进行故障转移和灾难恢复；然而，如果我们的web server并没有出现故障，能够被访问并且响应请求，但是响应速度非常的慢，每次请求都要过很久才能返回，原因可能是请求量太大，导致机器资源消耗严重无法正常响应。我们前面说过，当一个服务不能够正常的响应，就算它能够处理请求，也算是不可用。</p>
<p>那么遇到这种情况该怎么处理呢？这里我需要引入一个新的概念：Scaling—伸缩。这个概念在云服务中经常能够看到，AWS，Google cloud都号称自己的计算服务是Auto&nbsp;Scaling的，意思是他们的服务能够自动伸缩，这正是我们解决上述问题的关键。</p>
<p>我们希望达到的效果是：当web server资源（CPU，内存等）消耗达到很高的&#20540;时，我们能够启动新的web server缓解压力；与此同时，当过了高峰期，请求量降到很低时，我们能够关闭掉多余的服务器，不至于造成资源浪费。此时的架构应该是这样的：</p>
<p><img src="http://img.blog.csdn.net/20141229004324084?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3dlZXR2dmNr/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br><a href="https://app.yinxiang.com/shard/s18/sh/92a8e772-0432-4c4f-bbdd-ba4a449bd9fe/83b1eea9519c0456?content=#" title="下载" target="_blank" rel="external"></a><a href="https://app.yinxiang.com/shard/s18/sh/92a8e772-0432-4c4f-bbdd-ba4a449bd9fe/83b1eea9519c0456?content=#" title="图片集" target="_blank" rel="external"></a></p>
<p><img src="http://img.blog.csdn.net/20141229004345937?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3dlZXR2dmNr/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br><a href="https://app.yinxiang.com/shard/s18/sh/92a8e772-0432-4c4f-bbdd-ba4a449bd9fe/83b1eea9519c0456?content=#" title="下载" target="_blank" rel="external"></a><a href="https://app.yinxiang.com/shard/s18/sh/92a8e772-0432-4c4f-bbdd-ba4a449bd9fe/83b1eea9519c0456?content=#" title="图片集" target="_blank" rel="external"></a></p>
<p><img src="http://img.blog.csdn.net/20141229004405234?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3dlZXR2dmNr/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br><a href="https://app.yinxiang.com/shard/s18/sh/92a8e772-0432-4c4f-bbdd-ba4a449bd9fe/83b1eea9519c0456?content=#" title="下载" target="_blank" rel="external"></a><a href="https://app.yinxiang.com/shard/s18/sh/92a8e772-0432-4c4f-bbdd-ba4a449bd9fe/83b1eea9519c0456?content=#" title="图片集" target="_blank" rel="external"></a></p>
<p><img src="http://img.blog.csdn.net/20141229004420296?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3dlZXR2dmNr/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br><a href="https://app.yinxiang.com/shard/s18/sh/92a8e772-0432-4c4f-bbdd-ba4a449bd9fe/83b1eea9519c0456?content=#" title="下载" target="_blank" rel="external"></a><a href="https://app.yinxiang.com/shard/s18/sh/92a8e772-0432-4c4f-bbdd-ba4a449bd9fe/83b1eea9519c0456?content=#" title="图片集" target="_blank" rel="external"></a></p>
<p><img src="http://img.blog.csdn.net/20141229004433156?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3dlZXR2dmNr/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br><a href="https://app.yinxiang.com/shard/s18/sh/92a8e772-0432-4c4f-bbdd-ba4a449bd9fe/83b1eea9519c0456?content=#" title="下载" target="_blank" rel="external"></a><a href="https://app.yinxiang.com/shard/s18/sh/92a8e772-0432-4c4f-bbdd-ba4a449bd9fe/83b1eea9519c0456?content=#" title="图片集" target="_blank" rel="external"></a></p>
<p>通过上面的设计，这样的架构我们已经基本上可以称之为高可用的了。我们对每个环节都作了考虑，出现的问题也有了相应的处理方案，让服务保持一直可用——高可用。</p>
<p><strong>总结</strong></p>
<ul>
<li>Cluster/Distributed</li>
<li>HA&nbsp;Proxy(Load Balancing, Failover etc.)</li>
<li>Auto Scaling</li>
</ul>
<p>我们如果能够做好上面的三点，那么搭建一个高可用的架构就不是什么难事了，虽然上面三点都是难点 :p</p>
<p>后面的文章中将逐个讲解难点的攻破与实现，搭建高可用web服务。</p>
<p><strong>参考资料</strong></p>
<ul>
<li>AWS官网：<a href="http://aws.amazon.com/" target="_blank" rel="external">http://aws.amazon.com</a></li>
<li><p>AWS参考架构：<a href="http://aws.amazon.com/architecture/" target="_blank" rel="external">http://aws.amazon.com/architecture</a></p>
</li>
<li><p><a href="http://aws.amazon.com/architecture/" target="_blank" rel="external"></a></p>
</li>
</ul>
<pre><code>    作者：sweetvvck 发表于2014/12/28 23:22:03 [原文链接](http://blog.csdn.net/sweetvvck/article/details/42222429)


阅读：1071 评论：8 [查看评论](http://blog.csdn.net/sweetvvck/article/details/42222429#comments)
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>转载请注明出处：<a href="http://blog.csdn.net/sweetvvck/article/details/42222429" target="_blank" rel="external">设计高可用Web服务</a></p>
<p>高可用的设计可以说是]]>
    </summary>
    
      <category term="Web 架构" scheme="http://sweetvvck.github.io/tags/Web-%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[译]从S3中导入数据到Dynamodb]]></title>
    <link href="http://sweetvvck.github.io/2014/12/19/%E8%AF%91-%E4%BB%8ES3%E4%B8%AD%E5%AF%BC%E5%85%A5%E6%95%B0%E6%8D%AE%E5%88%B0Dynamodb/"/>
    <id>http://sweetvvck.github.io/2014/12/19/译-从S3中导入数据到Dynamodb/</id>
    <published>2014-12-19T11:04:20.000Z</published>
    <updated>2016-01-25T19:18:18.000Z</updated>
    <content type="html"><![CDATA[<p>本节假设你已经从Dynamodb中导出过数据，并且导出的文件以及被存入S3。<code>文件内部结构会在</code><a href="http://docs.aws.amazon.com/datapipeline/latest/DeveloperGuide/dp-importexport-ddb-pipelinejson-verifydata2.html" target="_blank" rel="external">Verify<br> Data Export File</a>&nbsp;中描述。</p>
<p> 我们称之前导出数据的原始表为<em>source table</em>，数据将要被导入的表为<em>destination table</em>。你可以将S3中的导出文件导入到dynamodb的表中，但是要先确保满足下面条件：</p>
<ul>
<li>The destination table 已经存在。 (导入任务不会为你创建表)</li>
<li>The destination table 与 source table 有相同的名称。</li>
<li>The destination table 与 source table 有相同的结构。<br>Destination table不一定要是空的。然而，导入进程会替换掉表中有相同主键的数据。例如，你有一个<em>Customer</em>&nbsp;表，它的主键是<em>CustomerId</em>，并且只有三个items (<em>CustomerId</em>&nbsp;1, 2, and 3)。如果要导入的文件中同样包含<em>CustomerID</em>&nbsp;为1,<br>2, and 3的items，这些在destination table中的items将会被导入文件中的数据替换。如果文件中还包含CustomerId为4的item，那么这个item会被加入到destination table中。<br>Destination table 可以在不同的AWS region。例如，假设你有个一个&nbsp;<em>Customer</em>&nbsp;table在US West (Oregon) region，然后将它的数据导出到了Amazon S3中。你可以将它导入到在&nbsp;EU (Ireland) region中有相同表明，相同主键的表中。这种做法被称为<br><em>cross-region</em>&nbsp;导出和导入。<br>注意到AWS管理控制台允许你一次导出多个表的数据。但是，不同的是，你一次只能导入一个表。</li>
</ul>
<p><strong>从S3导入数据到DynamoDB</strong></p>
<ol>
<li>登陆AWS管理控制台，然后打开dynamodb控制台：&nbsp;<a href="https://console.aws.amazon.com/dynamodb/" target="_blank" rel="external">https://console.aws.amazon.com/dynamodb/</a>.</li>
<li>(可选) 如果你想做块区域导入，点击右上角的Select a Region&nbsp;然后选择要导入的表的区域。控制台会显示该区域下的所有表。如果destination table不存在的话，你需要先创建它。</li>
<li>在&nbsp;Amazon DynamoDB Tables&nbsp;页面, 点击&nbsp;Export/Import.</li>
<li>在&nbsp;Export/Import&nbsp;页面，选择一个你要导入的表，然后点击&nbsp;Import into DynamoDB.</li>
<li>在&nbsp;Create Import Table Data Pipeline&nbsp;页面，按下面步骤操作：</li>
<li><ol>
<li>S3 Input Folder&nbsp;文本框中输入导入文件对应的 Amazon S3 URI。例如:&nbsp;<code>s3://mybucket/exports</code>这个URI的规则应该是这样&nbsp;<code>s3://&lt;code style=&quot;font-family:&#39;Courier New&#39;,Courier,mono&quot;&gt;bucketname</code>/<code>folder</code><br>:</li>
<li><ul>
<li><code>bucketname</code>&nbsp;是S3中bucket的名称</li>
<li><code>folder</code>&nbsp;表示存放要导入的文件的名称</li>
</ul>
<ol>
<li>导入任务会通过指定的S3位置找到对应的文件。<code>文件内部结构会在</code><a href="http://docs.aws.amazon.com/datapipeline/latest/DeveloperGuide/dp-importexport-ddb-pipelinejson-verifydata2.html" target="_blank" rel="external">Verify<br>Data Export File</a>&nbsp;中描述。</li>
</ol>
</li>
<li>在 S3 Log Folder&nbsp;文本框中输入一个S3 URI，导出过程的日志将被存储在相应的folder中。例如：<code>s3://mybucket/logs/</code></li>
</ol>
</li>
</ol>
<p>S3 Log Folder&nbsp;URI的&#26684;式和<br>S3 Output Folder的&#26684;式相同。</p>
<pre><code>5.  在&amp;nbsp;Throughput Rate&amp;nbsp;文本框中可选择一个百分比。这个比率表示在导出过程中会消耗读吞吐量的上限。例如，假设你要导出的表的读吞吐量是20，同时你设置的百分比是40%。那么导出时所消耗的吞吐量将不会超过8.
</code></pre><p>如果你在导出多个表，这个 Throughput Rate&nbsp;将会被应用到每个表中。</p>
<pre><code>6.  Execution Timeout&amp;nbsp;文本框，输入导出任务的超时时长。如果导出任务在这个时长内还没执行完成，此任务会失败。
7.  Send notifications to&amp;nbsp;文本框，输入一个email地址。在 pipeline被创建后，你将会收到一封email邀请订阅Amazon SNS；如果你接受了此邀请，在每次执行导出操作时你都将会收到email通知。
8.  Data Pipeline Role, 选择&amp;nbsp;DataPipelineDefaultRole.
9.  Resource Role, 选择&amp;nbsp;DataPipelineDefaultResourceRole
</code></pre><ol>
<li>确认好以上设置然后点击 Create Export Pipeline.<br>你的 pipeline 现在将被创建；这个过程可能会花费几分钟完成。要查看当前状态，移步 <a href="http://docs.aws.amazon.com/zh_cn/amazondynamodb/latest/developerguide/DataPipelineExportImport.ManagingPipelines.html" target="_blank" rel="external">Managing Export and Import Pipelines</a> “Managing Export and Import Pipelines”).<br>导入任务会在你的pipeline创建好后立即执行。</li>
</ol>
<pre><code>作者：sweetvvck 发表于2014/12/19 19:04:20
[原文链接](http://blog.csdn.net/sweetvvck/article/details/42030729)
阅读：1037 评论：0
[查看评论](http://blog.csdn.net/sweetvvck/article/details/42030729#comments)
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>本节假设你已经从Dynamodb中导出过数据，并且导出的文件以及被存入S3。<code>文件内部结构会在</code><a href="http://docs.aws.amazon.com/datapipeline/latest/DeveloperGuide/dp-impo]]>
    </summary>
    
      <category term="Aws" scheme="http://sweetvvck.github.io/tags/Aws/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[译]Aws Dynamodb数据导出到S3]]></title>
    <link href="http://sweetvvck.github.io/2014/12/19/%E8%AF%91-Aws-Dynamodb%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%87%BA%E5%88%B0S3/"/>
    <id>http://sweetvvck.github.io/2014/12/19/译-Aws-Dynamodb数据导出到S3/</id>
    <published>2014-12-19T03:55:21.000Z</published>
    <updated>2016-01-25T19:47:07.000Z</updated>
    <content type="html"><![CDATA[<p>本节将描述如何从一个或多个DynamoDB的表导出数据到S3的bucket中。在执行导出之前你需要提前创建好S3的bucket。<br><strong>注意</strong><br>如果你还没有使用过AWS Data Pipeline，在执行下面的流程前你需要先去创建两个IAM roles。更多信息，请移步<br><a href="http://docs.aws.amazon.com/zh_cn/amazondynamodb/latest/developerguide/DataPipelineExportImport.Prereqs.html#DataPipelineExportImport.Prereqs.IAMRoles" title="Creating IAM Roles for AWS Data Pipeline" target="_blank" rel="external"><br>Creating IAM Roles for AWS Data Pipeline</a>。<br><strong>从DynamoDB中导出数据到S3</strong></p>
<ol>
<li>登陆到AWS管理员控制台，打开DynamoDB console。&nbsp;<a href="https://console.aws.amazon.com/dynamodb/" target="_blank" rel="external">https://console.aws.amazon.com/dynamodb/</a>.</li>
<li>在&nbsp;Amazon DynamoDB Tables&nbsp;页面, 点击&nbsp;Export/Import.</li>
<li>在 Export/Import 页面, 选择你想导出的表，然后点击<br>Export from DynamoDB.</li>
<li>在&nbsp;Create Export Table Data Pipeline(s)&nbsp;页面，按下面流程操作：</li>
<li><ol>
<li>在&nbsp;S3 Output Folder&nbsp;文本框中填写 Amazon S3 URI，导出文件将存放在S3中相应的文件夹下。例如：<br><code>s3://mybucket/exports</code></li>
</ol>
</li>
</ol>
<p>这个URI的规则应该是这样&nbsp;<code>s3://bucketname</code>/<code>folder</code><br> :</p>
<pre><code>2.  *   `bucketname`&amp;nbsp;是S3中bucket的名称
    *   `folder`&amp;nbsp;表示此bucket下文件夹的名称。如果这个文件夹不存在，它将被自动创建。如果你不指定这个名称，它将被自动授予一个名字，名字的规则是：
</code></pre><p><code>s3://bucketname</code>/<code>region</code>/<code>tablename</code>.</p>
<pre><code>3.  在 S3 Log Folder&amp;nbsp;文本框中输入一个S3 URI，导出过程的日志将被存储在相应的folder中。例如：`s3://mybucket/logs/`
</code></pre><p>S3 Log Folder&nbsp;URI的&#26684;式和<br>S3 Output Folder的&#26684;式相同。</p>
<pre><code>4.  在&amp;nbsp;Throughput Rate&amp;nbsp;文本框中可选择一个百分比。这个比率表示在导出过程中会消耗读吞吐量的上限。例如，假设你要导出的表的读吞吐量是20，同时你设置的百分比是40%。那么导出时所消耗的吞吐量将不会超过8.
</code></pre><p>如果你在导出多个表，这个 Throughput Rate&nbsp;将会被应用到每个表中。</p>
<pre><code>5.  Execution Timeout&amp;nbsp;文本框，输入导出任务的超时时长。如果导出任务在这个时长内还没执行完成，此任务会失败。
6.  Send notifications to&amp;nbsp;文本框，输入一个email地址。在 pipeline被创建后，你将会收到一封email邀请订阅Amazon SNS；如果你接受了此邀请，在每次执行导出操作时你都将会收到email通知。
7.  &amp;nbsp;Schedule&amp;nbsp;选项，选择下面其中一项：
8.  *   One-time Export&amp;nbsp;—导出任务将在pipeline被创建后立即执行。
    *   Daily Export&amp;nbsp;— 导出任务将会在你所指定的时刻执行，同时会在每天的那个时刻重复。

    9.  Data Pipeline Role, 选择&amp;nbsp;DataPipelineDefaultRole.
10.  Resource Role, 选择&amp;nbsp;DataPipelineDefaultResourceRole
</code></pre><ol>
<li>确认好以上设置然后点击&nbsp;Create Export Pipeline.<br>你的 pipeline 现在将被创建；这个过程可能会花费几分钟完成。要查看当前状态，移步&nbsp;<a href="http://docs.aws.amazon.com/zh_cn/amazondynamodb/latest/developerguide/DataPipelineExportImport.ManagingPipelines.html" title="Managing Export and Import Pipelines" target="_blank" rel="external">Managing<br>Export and Import Pipelines</a>.<br>如果你选择的Schedule是 one-time export，导出任务将在pipeline 创建成功后立即执行。如果你选择的是daily export，导出任务将会在指定时刻执行，同时会在每天的那个时刻执行导出任务。<br>当导出任务结束，你可以到 <a href="http://console.aws.amazon.com/s3" target="_blank" rel="external"><br>Amazon S3 console</a>&nbsp;来查看导出文件。这个文件将会在以你的表名命名的文件夹中，而文件名将会是这种&#26684;式：&nbsp;<code>[YYYY-MM-DD_HH.MM](http://YYYY-MM-DD_HH.MM)。文件内部结构会在</code><a href="http://docs.aws.amazon.com/datapipeline/latest/DeveloperGuide/dp-importexport-ddb-pipelinejson-verifydata2.html" target="_blank" rel="external">Verify<br>Data Export File</a>&nbsp;中描述。</li>
</ol>
<pre><code>    作者：sweetvvck 发表于2014/12/19 11:55:21 [原文链接](http://blog.csdn.net/sweetvvck/article/details/42026517)


阅读：1174 评论：1 [查看评论](http://blog.csdn.net/sweetvvck/article/details/42026517#comments)
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>本节将描述如何从一个或多个DynamoDB的表导出数据到S3的bucket中。在执行导出之前你需要提前创建好S3的bucket。<br><strong>注意</strong><br>如果你还没有使用过AWS Data Pipeline，在执行下面的流程前你需要先去创建两个I]]>
    </summary>
    
      <category term="Aws" scheme="http://sweetvvck.github.io/tags/Aws/"/>
    
      <category term="Dynamodb" scheme="http://sweetvvck.github.io/tags/Dynamodb/"/>
    
      <category term="S3" scheme="http://sweetvvck.github.io/tags/S3/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[译]Android学习路线（三十三）缓存Bitmap]]></title>
    <link href="http://sweetvvck.github.io/2014/10/31/%E8%AF%91-Android%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%EF%BC%88%E4%B8%89%E5%8D%81%E4%B8%89%EF%BC%89%E7%BC%93%E5%AD%98Bitmap/"/>
    <id>http://sweetvvck.github.io/2014/10/31/译-Android学习路线（三十三）缓存Bitmap/</id>
    <published>2014-10-31T15:43:14.000Z</published>
    <updated>2016-01-25T20:06:49.000Z</updated>
    <content type="html"><![CDATA[<p>加载一个bitmap到UI上是很简单的，然而，如果要一次加载一个大的图片集事情就变的复杂了许多。在多数情况下（例如在使用在<a href="http://developer.android.com/reference/android/widget/ListView.html" target="_blank" rel="external">ListView</a>,<a href="http://developer.android.com/reference/android/widget/GridView.html" target="_blank" rel="external">GridView</a>和<a href="http://developer.android.com/reference/android/support/v4/view/ViewPager.html" target="_blank" rel="external">ViewPager</a>中），屏幕上的图片以及将要滚动到屏幕的图片的总数大体上是无限的。</p>
<p>内存使用量可以通过回收不在屏幕上显示的子View来保持较低的状态。在不保持引用长期有效的情况下，GC也会将这些加载过的bitmaps回收。 这样做其实很好，但是要保持一个流畅快速响应的UI，你可能想要避免每次都重复的加载图片近内存。在这种情况下，磁盘加上内存双重缓存能够帮上大忙，它能够让相同的图片快速复用。</p>
<p>本课介绍使用加载大量图片的情况下使用磁盘内存缓存来提升UI的响应速度和流畅度。</p>
<h2 id="u4F7F_u7528_u5185_u5B58_u7F13_u5B58"><a href="#u4F7F_u7528_u5185_u5B58_u7F13_u5B58" class="headerlink" title="使用内存缓存"></a>使用内存缓存</h2><hr>
<p>内存缓存是通过消耗珍贵的app内存资源来提供快速访问bitmaps的功能。<a href="http://developer.android.com/reference/android/util/LruCache.html" target="_blank" rel="external">LruCache</a>类<br> (API等级4以上的低版本可以使用<a href="http://developer.android.com/reference/android/support/v4/util/LruCache.html" target="_blank" rel="external">Support Library</a>) 是专用的缓存bitmaps的，它将最近使用的bitmaps的强引用保存在一个<a href="http://developer.android.com/reference/java/util/LinkedHashMap.html" target="_blank" rel="external">LinkedHashMap</a>中，当缓存数量达到限制时将最久没有使用过的引用从缓存中剔除。</p>
<p><strong>提示:</strong>在之前，流行的内存缓存实现使用的都是<a href="http://developer.android.com/reference/java/lang/ref/SoftReference.html" target="_blank" rel="external">SoftReference</a>或者<a href="http://developer.android.com/reference/java/lang/ref/WeakReference.html" target="_blank" rel="external">WeakReference</a>bitmap<br> 缓存，然而这样不被推荐。从Android 2.3 (API Level 9)开始，GC对soft/weak 引用的回收大大加强了，这回导致它们很快就失效了。</p>
<p>要为<a href="http://developer.android.com/reference/android/util/LruCache.html" target="_blank" rel="external">LruCache</a>选择一个合适的大小，下面几点因素需要考虑：</p>
<ul>
<li>你的App所剩余的内存情况？</li>
<li>一次在屏幕上会显示多少图片？有多少图片准备好在屏幕上显示？</li>
<li>设备的屏幕大小和密度？高分辨率例如密度为xhdpi的设备需要一个更大的缓存来在内存上保存相同数量的图片。</li>
<li>这些Bitmaps的尺寸和配置，以及它们所需要消耗的内存大小。</li>
<li>这些图片被访问的频度是多少？是否它们中的某些比剩余的访问频度高很多？如果是这样，你可能想要将这些高频访问的图片一直放在内存中，或者使用多个LruCache用于不同频度的bitmaps集合。</li>
<li>你能够保持数量和质量的平衡吗？有时候保存大量的低分辨率bitmaps，然后在后台加载他们的高分辨率版本是很有效的做法。</li>
</ul>
<p>没有一个能够适用于所有app的LruCache的大小和使用方式，这要依据不同app的内存使用量和一些其他因素，经过分析后得出一个最佳方案。缓存太小只会带来额外的内存消耗而没有任何好处，然而缓存太大又有可能导致java.lang.OutOfMemory异常，得不偿失。</p>
<p>下面是为Bitmaps设置LruCache的示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> LruCache&amp;lt;String, Bitmap&amp;gt; mMemoryCache;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// Get max available VM memory, exceeding this amount will throw an</span></span><br><span class="line">  <span class="comment">// OutOfMemory exception. Stored in kilobytes as LruCache takes an</span></span><br><span class="line">  <span class="comment">// int in its constructor.</span></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> maxMemory = (<span class="keyword">int</span>) (Runtime.getRuntime().maxMemory() / <span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Use 1/8th of the available memory for this memory cache.</span></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> cacheSize = maxMemory / <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">  mMemoryCache = <span class="keyword">new</span> LruCache&amp;lt;String, Bitmap&amp;gt;(cacheSize) &#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">sizeOf</span><span class="params">(String key, Bitmap bitmap)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// The cache size will be measured in kilobytes rather than</span></span><br><span class="line">      <span class="comment">// number of items.</span></span><br><span class="line">      <span class="keyword">return</span> bitmap.getByteCount() / <span class="number">1024</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBitmapToMemoryCache</span><span class="params">(String key, Bitmap bitmap)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (getBitmapFromMemCache(key) == <span class="keyword">null</span>) &#123;</span><br><span class="line">    mMemoryCache.put(key, bitmap);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Bitmap <span class="title">getBitmapFromMemCache</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> mMemoryCache.get(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>提示:</strong>在本例中，app所分配内存的1/8用于缓存。在普通或者较高分辨率的设备中，缓存的大小大约为4MB (32/8)。一个在分辨率为800x480的设备上被图片覆盖，全屏显示的<a href="http://developer.android.com/reference/android/widget/GridView.html" target="_blank" rel="external">GridView</a>，将会消耗大约1.5MB<br> (800<em>480</em>4 字节)内存，这样本例中的LruCache就能够缓存2.5页图片。</p>
<p>当加载bitmap到ImageView中时，LruCache会首先检查该bitmap是否已经缓存。如果已经找到对应对象就直接更新到ImageView中，否则就生成一个后台线程加载图片：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadBitmap</span><span class="params">(<span class="keyword">int</span> resId, ImageView imageView)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> String imageKey = String.valueOf(resId);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> Bitmap bitmap = getBitmapFromMemCache(imageKey);</span><br><span class="line">  <span class="keyword">if</span> (bitmap != <span class="keyword">null</span>) &#123;</span><br><span class="line">    mImageView.setImageBitmap(bitmap);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    mImageView.setImageResource(R.drawable.image_placeholder);</span><br><span class="line">    BitmapWorkerTask task = <span class="keyword">new</span> BitmapWorkerTask(mImageView);</span><br><span class="line">    task.execute(resId);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[BitmapWorkerTask](http:<span class="comment">//developer.android.com/training/displaying-bitmaps/process-bitmap.html#BitmapWorkerTask)同样需要被更新，加载对象到内存缓存：</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BitmapWorkerTask</span> <span class="keyword">extends</span> <span class="title">AsyncTask</span>&amp;<span class="title">lt</span></span>;Integer, Void, Bitmap&amp;gt; &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// Decode image in background.</span></span><br><span class="line">  <span class="annotation">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> Bitmap <span class="title">doInBackground</span><span class="params">(Integer... params)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Bitmap bitmap = decodeSampledBitmapFromResource(</span><br><span class="line">        getResources(), params[<span class="number">0</span>], <span class="number">100</span>, <span class="number">100</span>));</span><br><span class="line">    addBitmapToMemoryCache(String.valueOf(params[<span class="number">0</span>]), bitmap);</span><br><span class="line">    <span class="keyword">return</span> bitmap;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="u4F7F_u7528_u78C1_u76D8_u7F13_u5B58"><a href="#u4F7F_u7528_u78C1_u76D8_u7F13_u5B58" class="headerlink" title="使用磁盘缓存"></a>使用磁盘缓存</h2><hr>
<p>内存缓存能够大大提升访问速度，然而你不能依赖这些缓存能够一直存在。像<a href="http://developer.android.com/reference/android/widget/GridView.html" target="_blank" rel="external">GridView</a>这种拥有大量数据的组件会很快的填满内存缓存。你的App也会被被其他任务中断例如有人打电话过来，当你再次回到app时，它可能已经被杀死，同时内存缓存都被清理掉了，这些图片又需要再次被加载进来。</p>
<p>磁盘缓存可以用于这些情况，将加载过的bitmaps持久化到磁盘中，减少加载那些已经不在内存中存在的图片的时间。当然，由于从磁盘读取的时间不能被预测，速度比从内存读取慢上许多并且需要再后台线程中加载。</p>
<p><strong>提示:</strong><a href="http://developer.android.com/reference/android/content/ContentProvider.html" target="_blank" rel="external">ContentProvider</a>可能更适合存放那些被频繁访问的图片，例如在相册应用中那样。</p>
<p>下面使用了DiskLruCache的示例代码是从<a href="https://android.googlesource.com/platform/libcore/&#43;/jb-mr2-release/luni/src/main/java/libcore/io/DiskLruCache.java" target="_blank" rel="external">Android<br> source</a>中抽取出来的，同时加入了内存缓存：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">private DiskLruCache mDiskLruCache;</span><br><span class="line">private final Object mDiskCacheLock = new Object();</span><br><span class="line">private boolean mDiskCacheStarting = true;</span><br><span class="line">private static final int DISK_CACHE_SIZE = 1024 * 1024 * 10; // 10MB</span><br><span class="line">private static final String DISK_CACHE_SUBDIR = &amp;quot;thumbnails&amp;quot;;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">  ...</span><br><span class="line">  // Initialize memory cache</span><br><span class="line">  ...</span><br><span class="line">  // Initialize disk cache on background thread</span><br><span class="line">  File cacheDir = getDiskCacheDir(this, DISK_CACHE_SUBDIR);</span><br><span class="line">  new InitDiskCacheTask().execute(cacheDir);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class InitDiskCacheTask extends AsyncTask&amp;lt;File, Void, Void&amp;gt; &#123;</span><br><span class="line">  @Override</span><br><span class="line">  protected Void doInBackground(File... params) &#123;</span><br><span class="line">    synchronized (mDiskCacheLock) &#123;</span><br><span class="line">      File cacheDir = params[0];</span><br><span class="line">      mDiskLruCache = DiskLruCache.open(cacheDir, DISK_CACHE_SIZE);</span><br><span class="line">      mDiskCacheStarting = false; // Finished initialization</span><br><span class="line">      mDiskCacheLock.notifyAll(); // Wake any waiting threads</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class BitmapWorkerTask extends AsyncTask&amp;lt;Integer, Void, Bitmap&amp;gt; &#123;</span><br><span class="line">  ...</span><br><span class="line">  // Decode image in background.</span><br><span class="line">  @Override</span><br><span class="line">  protected Bitmap doInBackground(Integer... params) &#123;</span><br><span class="line">    final String imageKey = String.valueOf(params[0]);</span><br><span class="line"></span><br><span class="line">    // Check disk cache in background thread</span><br><span class="line">    Bitmap bitmap = getBitmapFromDiskCache(imageKey);</span><br><span class="line"></span><br><span class="line">    if (bitmap == null) &#123; // Not found in disk cache</span><br><span class="line">      // Process as normal</span><br><span class="line">      final Bitmap bitmap = decodeSampledBitmapFromResource(</span><br><span class="line">          getResources(), params[0], 100, 100));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Add final bitmap to caches</span><br><span class="line">    addBitmapToCache(imageKey, bitmap);</span><br><span class="line"></span><br><span class="line">    return bitmap;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void addBitmapToCache(String key, Bitmap bitmap) &#123;</span><br><span class="line">  // Add to memory cache as before</span><br><span class="line">  if (getBitmapFromMemCache(key) == null) &#123;</span><br><span class="line">    mMemoryCache.put(key, bitmap);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Also add to disk cache</span><br><span class="line">  synchronized (mDiskCacheLock) &#123;</span><br><span class="line">    if (mDiskLruCache != null &amp;amp;&amp;amp; mDiskLruCache.get(key) == null) &#123;</span><br><span class="line">      mDiskLruCache.put(key, bitmap);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Bitmap getBitmapFromDiskCache(String key) &#123;</span><br><span class="line">  synchronized (mDiskCacheLock) &#123;</span><br><span class="line">    // Wait while disk cache is started from background thread</span><br><span class="line">    while (mDiskCacheStarting) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        mDiskCacheLock.wait();</span><br><span class="line">      &#125; catch (InterruptedException e) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (mDiskLruCache != null) &#123;</span><br><span class="line">      return mDiskLruCache.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Creates a unique subdirectory of the designated app cache directory. Tries to use external</span><br><span class="line">// but if not mounted, falls back on internal storage.</span><br><span class="line">public static File getDiskCacheDir(Context context, String uniqueName) &#123;</span><br><span class="line">  // Check if media is mounted or storage is built-in, if so, try and use external cache dir</span><br><span class="line">  // otherwise use internal cache dir</span><br><span class="line">  final String cachePath =</span><br><span class="line">      Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState()) ||</span><br><span class="line">          !isExternalStorageRemovable() ? getExternalCacheDir(context).getPath() :</span><br><span class="line">              context.getCacheDir().getPath();</span><br><span class="line"></span><br><span class="line">  return new File(cachePath &amp;#43; File.separator &amp;#43; uniqueName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>提示:</strong>初始化磁盘缓存也需要磁盘操作，同样不能在主线程中执行。然而，这就意味着会有缓存没有初始化完就被使用的情况出现。要避免这种情况，在上面的实现代码中，使用了一个锁对象保证在磁盘缓存初始化完成前不能被使用。</p>
<p>内存缓存在UI线程中检查，而磁盘缓存则在后台线程中检查。当一个图片被加载完成，它将被同时加入到内存和磁盘缓存，用于之后的使用。</p>
<h2 id="u5904_u7406_u914D_u7F6E_u53D8_u5316_uFF08_u4F8B_u5982_u6A2A_u7AD6_u5C4F_u5207_u6362_uFF09"><a href="#u5904_u7406_u914D_u7F6E_u53D8_u5316_uFF08_u4F8B_u5982_u6A2A_u7AD6_u5C4F_u5207_u6362_uFF09" class="headerlink" title="处理配置变化（例如横竖屏切换）"></a>处理配置变化（例如横竖屏切换）</h2><hr>
<p>运行时配置发生配置变化，例如屏幕方向切换，导致Android系统使用新的配置重启activity。你想要做的是在发生这种情况时不要影响到缓存机制。</p>
<p>幸运的是，在上面“使用内存缓存”那一节中讲解了一个很棒的内存缓存示例。这个缓存可以通过<a href="http://developer.android.com/reference/android/app/Fragment.html" target="_blank" rel="external">Fragment</a>传递给新的activity中。</p>
<p>下面是使用Fragment保持<a href="http://developer.android.com/reference/android/util/LruCache.html" target="_blank" rel="external">LruCache</a>对象的示例代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> LruCache&amp;lt;String, Bitmap&amp;gt; mMemoryCache;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  RetainFragment retainFragment =</span><br><span class="line">      RetainFragment.findOrCreateRetainFragment(getFragmentManager());</span><br><span class="line">  mMemoryCache = retainFragment.mRetainedCache;</span><br><span class="line">  <span class="keyword">if</span> (mMemoryCache == <span class="keyword">null</span>) &#123;</span><br><span class="line">    mMemoryCache = <span class="keyword">new</span> LruCache&amp;lt;String, Bitmap&amp;gt;(cacheSize) &#123;</span><br><span class="line">      ... <span class="comment">// Initialize cache here as usual</span></span><br><span class="line">    &#125;</span><br><span class="line">    retainFragment.mRetainedCache = mMemoryCache;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RetainFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = &amp;quot;RetainFragment&amp;quot;;</span><br><span class="line">  <span class="keyword">public</span> LruCache&amp;lt;String, Bitmap&amp;gt; mRetainedCache;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">RetainFragment</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RetainFragment <span class="title">findOrCreateRetainFragment</span><span class="params">(FragmentManager fm)</span> </span>&#123;</span><br><span class="line">    RetainFragment fragment = (RetainFragment) fm.findFragmentByTag(TAG);</span><br><span class="line">    <span class="keyword">if</span> (fragment == <span class="keyword">null</span>) &#123;</span><br><span class="line">      fragment = <span class="keyword">new</span> RetainFragment();</span><br><span class="line">      fm.beginTransaction().add(fragment, TAG).commit();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fragment;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="annotation">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setRetainInstance(<span class="keyword">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>    作者：sweetvvck 发表于2014/10/31 23:43:14 [原文链接](http://blog.csdn.net/sweetvvck/article/details/40664009)


阅读：373 评论：0 [查看评论](http://blog.csdn.net/sweetvvck/article/details/40664009#comments)
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>加载一个bitmap到UI上是很简单的，然而，如果要一次加载一个大的图片集事情就变的复杂了许多。在多数情况下（例如在使用在<a href="http://developer.android.com/reference/android/widget/ListView.html]]>
    </summary>
    
      <category term="Android" scheme="http://sweetvvck.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[译]Android学习路线（三十二）在非UI线程中处理Bitmap]]></title>
    <link href="http://sweetvvck.github.io/2014/10/31/%E8%AF%91-Android%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%EF%BC%88%E4%B8%89%E5%8D%81%E4%BA%8C%EF%BC%89%E5%9C%A8%E9%9D%9EUI%E7%BA%BF%E7%A8%8B%E4%B8%AD%E5%A4%84%E7%90%86Bitmap/"/>
    <id>http://sweetvvck.github.io/2014/10/31/译-Android学习路线（三十二）在非UI线程中处理Bitmap/</id>
    <published>2014-10-31T15:41:35.000Z</published>
    <updated>2016-01-25T20:06:45.000Z</updated>
    <content type="html"><![CDATA[<p>如果图片源数据是从硬盘，网络或是其他非内存中读取的话，在<a href="http://developer.android.com/training/displaying-bitmaps/load-bitmap.html" target="_blank" rel="external">高效地夹在大Bitmaps</a>中讨论的<a href="http://developer.android.com/reference/android/graphics/BitmapFactory.html#decodeByteArray(byte[], int, int, android.graphics.BitmapFactory.Options" target="_blank" rel="external">BitmapFactory.decode*</a>)方法就不能在主线程（UI线程）中执行。这种数据加载进内存的时间是不可预测的，并且还要依赖各种其他因素（磁盘读取速度，网络速度，图片大小，CPU性能等等）。如果这些任务的其中之一阻塞了UI线程，那么系统就认为你的app处于无响应状态并且弹出对话框提示用户关闭app。</p>
<p>本课介绍如何使用&nbsp;<a href="http://developer.android.com/reference/android/os/AsyncTask.html" target="_blank" rel="external">AsyncTask</a>&nbsp;在后台线程中处理bitmaps，同时粗略讲解如何处理并发事件。</p>
<h2 id="u4F7F_u7528AsyncTask"><a href="#u4F7F_u7528AsyncTask" class="headerlink" title="使用AsyncTask"></a>使用AsyncTask</h2><hr>
<p><a href="http://developer.android.com/reference/android/os/AsyncTask.html" target="_blank" rel="external">AsyncTask</a>&nbsp;类提供了一个简单的方法来在后台线程处理任务，并且能够将处理结果在UI线程中返回。要使用它，需创建一个它的子类，然后覆盖几个必要的方法。下面这个例子向你展示如何使用&nbsp;<a href="http://developer.android.com/reference/android/os/AsyncTask.html" target="_blank" rel="external">AsyncTask</a>&nbsp;和<a href="http://developer.android.com/training/displaying-bitmaps/load-bitmap.html#decodeSampledBitmapFromResource" target="_blank" rel="external"><code>decodeSampledBitmapFromResource()</code></a>将大bitmap加载到ImageView中：</p>
<p>class BitmapWorkerTask extends AsyncTask&lt;Integer, Void, Bitmap&gt; {<br>&nbsp; &nbsp; private final WeakReference&lt;ImageView&gt; imageViewReference;<br>&nbsp; &nbsp; private int data = 0;</p>
<p>&nbsp; &nbsp; public BitmapWorkerTask(ImageView imageView) {<br>&nbsp; &nbsp; &nbsp; &nbsp; // Use a WeakReference to ensure the ImageView can be garbage collected<br>&nbsp; &nbsp; &nbsp; &nbsp; imageViewReference = new WeakReference&lt;ImageView&gt;(imageView);<br>&nbsp; &nbsp; }</p>
<p>&nbsp; &nbsp; // Decode image in background.<br>&nbsp; &nbsp; @Override<br>&nbsp; &nbsp; protected Bitmap doInBackground(Integer… params) {<br>&nbsp; &nbsp; &nbsp; &nbsp; data = params[0];<br>&nbsp; &nbsp; &nbsp; &nbsp; return decodeSampledBitmapFromResource(getResources(), data, 100, 100));<br>&nbsp; &nbsp; }</p>
<p>&nbsp; &nbsp; // Once complete, see if ImageView is still around and set bitmap.<br>&nbsp; &nbsp; @Override<br>&nbsp; &nbsp; protected void onPostExecute(Bitmap bitmap) {<br>&nbsp; &nbsp; &nbsp; &nbsp; if (imageViewReference != null &amp;&amp; bitmap != null) {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; final ImageView imageView = imageViewReference.get();<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (imageView != null) {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; imageView.setImageBitmap(bitmap);<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; }<br>}</p>
<p><a href="http://developer.android.com/reference/android/widget/ImageView.html" target="_blank" rel="external">ImageView</a>&nbsp;到<a href="http://developer.android.com/reference/java/lang/ref/WeakReference.html" target="_blank" rel="external">WeakReference</a>&nbsp;确保了<a href="http://developer.android.com/reference/android/os/AsyncTask.html" target="_blank" rel="external">AsyncTask</a>&nbsp;不会阻止<a href="http://developer.android.com/reference/android/widget/ImageView.html" target="_blank" rel="external">ImageView</a>&nbsp;以及它引用的对象不会被垃圾回收。由于并不能确保&nbsp;<a href="http://developer.android.com/reference/android/widget/ImageView.html" target="_blank" rel="external">ImageView</a>&nbsp;在任务执行结束后仍然存在，我们在使用它之前需要对它进行检查。<a href="http://developer.android.com/reference/android/widget/ImageView.html" target="_blank" rel="external">ImageView</a>&nbsp;有可能已经不存在了，例如，用户切换到其他的activity中又或者在任务结束前发生了配置改变（横竖屏切换）都可能导致上述情况。</p>
<p>要异步地加载这个bitmap，只需要简单地执行下面的代码：</p>
<p>public void loadBitmap(int resId, ImageView imageView) {<br>&nbsp; &nbsp; BitmapWorkerTask task = new BitmapWorkerTask(imageView);<br>&nbsp; &nbsp; task.execute(resId);<br>}</p>
<h2 id="u5904_u7406_u5E76_u53D1"><a href="#u5904_u7406_u5E76_u53D1" class="headerlink" title="处理并发"></a>处理并发</h2><hr>
<p>通常的视图组件像<a href="http://developer.android.com/reference/android/widget/ListView.html" target="_blank" rel="external">ListView</a>&nbsp;和&nbsp;<a href="http://developer.android.com/reference/android/widget/GridView.html" target="_blank" rel="external">GridView</a>，如果像上一节中示范的那样与&nbsp;<a href="http://developer.android.com/reference/android/os/AsyncTask.html" target="_blank" rel="external">AsyncTask</a>&nbsp;一起使用会引出其他的问题。为了提高内存使用效率，这些组件在滚动过程中会重用它们的子View。如果每个子View都触发了一个&nbsp;<a href="http://developer.android.com/reference/android/os/AsyncTask.html" target="_blank" rel="external">AsyncTask</a>，那么这些AsyncTask结束后没有任何确保，它们之前关联的View可能已经被重用了。并且，AsyncTask开始的顺序并不意味着它们的结束顺训。</p>
<p><a href="http://android-developers.blogspot.com/2010/07/multithreading-for-performance.html" target="_blank" rel="external">Multithreading for Performance</a>&nbsp;这片文章讨论了如何处理并发，并且提供了提供了一个解决方法：将ImageView的引用存储起来，然后等到&nbsp;<a href="http://developer.android.com/reference/android/os/AsyncTask.html" target="_blank" rel="external">AsyncTask</a>&nbsp;结束后查找对应的引用。使用一个类&#20284;的方法，上一节使用的&nbsp;<a href="http://developer.android.com/reference/android/os/AsyncTask.html" target="_blank" rel="external">AsyncTask</a>&nbsp;将会使用类&#20284;的模式进行简单的扩展。</p>
<p>创建一个专用的<a href="http://developer.android.com/reference/android/graphics/drawable/Drawable.html" target="_blank" rel="external">Drawable</a>&nbsp;子类来存储任务的引用。在这种情况下，这个<a href="http://developer.android.com/reference/android/graphics/drawable/BitmapDrawable.html" target="_blank" rel="external">BitmapDrawable</a>&nbsp;的作用是让一个占位的图片在task结束后能够被显示在这个ImageView上：</p>
<p>static class AsyncDrawable extends BitmapDrawable {<br>&nbsp; &nbsp; private final WeakReference&lt;BitmapWorkerTask&gt; bitmapWorkerTaskReference;</p>
<p>&nbsp; &nbsp; public AsyncDrawable(Resources res, Bitmap bitmap,<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BitmapWorkerTask bitmapWorkerTask) {<br>&nbsp; &nbsp; &nbsp; &nbsp; super(res, bitmap);<br>&nbsp; &nbsp; &nbsp; &nbsp; bitmapWorkerTaskReference =<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new WeakReference&lt;BitmapWorkerTask&gt;(bitmapWorkerTask);<br>&nbsp; &nbsp; }</p>
<p>&nbsp; &nbsp; public BitmapWorkerTask getBitmapWorkerTask() {<br>&nbsp; &nbsp; &nbsp; &nbsp; return bitmapWorkerTaskReference.get();<br>&nbsp; &nbsp; }<br>}</p>
<p>在执行<a href="http://developer.android.com/training/displaying-bitmaps/process-bitmap.html#BitmapWorkerTask" target="_blank" rel="external">BitmapWorkerTask</a>之前，你需要先创建一个<a href="http://developer.android.com/training/displaying-bitmaps/process-bitmap.html#AsyncDrawable" target="_blank" rel="external"><code>AsyncDrawable</code></a>&nbsp;同时将它绑定到目标<a href="http://developer.android.com/reference/android/widget/ImageView.html" target="_blank" rel="external">ImageView</a>：</p>
<p>public void loadBitmap(int resId, ImageView imageView) {<br>&nbsp; &nbsp; if (cancelPotentialWork(resId, imageView)) {<br>&nbsp; &nbsp; &nbsp; &nbsp; final BitmapWorkerTask task = new BitmapWorkerTask(imageView);<br>&nbsp; &nbsp; &nbsp; &nbsp; final AsyncDrawable asyncDrawable =<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; new AsyncDrawable(getResources(), mPlaceHolderBitmap, task);<br>&nbsp; &nbsp; &nbsp; &nbsp; imageView.setImageDrawable(asyncDrawable);<br>&nbsp; &nbsp; &nbsp; &nbsp; task.execute(resId);<br>&nbsp; &nbsp; }<br>}</p>
<p><code>cancelPotentialWork</code>&nbsp;和上面的代码示例对应，检查是否已经有一个运行中的task与此ImageView相关联。如果是，此方法尝试通过调用<a href="http://developer.android.com/reference/android/os/AsyncTask.html#cancel(boolean" target="_blank" rel="external">cancel()</a>)方法取消此任务。在少数情况下，新的task数据和已经存在的task匹配，即可直接返回。下面是<code>cancelPotentialWork</code>的示例代码：</p>
<p>public static boolean cancelPotentialWork(int data, ImageView imageView) {<br>&nbsp; &nbsp; final BitmapWorkerTask bitmapWorkerTask = getBitmapWorkerTask(imageView);</p>
<p>&nbsp; &nbsp; if (bitmapWorkerTask != null) {<br>&nbsp; &nbsp; &nbsp; &nbsp; final int bitmapData = bitmapWorkerTask.data;<br>&nbsp; &nbsp; &nbsp; &nbsp; // If bitmapData is not yet set or it differs from the new data<br>&nbsp; &nbsp; &nbsp; &nbsp; if (bitmapData == 0 || bitmapData != data) {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Cancel previous task<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bitmapWorkerTask.cancel(true);<br>&nbsp; &nbsp; &nbsp; &nbsp; } else {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // The same work is already in progress<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;<br>&nbsp; &nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; }<br>&nbsp; &nbsp; // No task associated with the ImageView, or an existing task was cancelled<br>&nbsp; &nbsp; return true;<br>}</p>
<p><code>getBitmapWorkerTask()</code>, 用于获取与指定<a href="http://developer.android.com/reference/android/widget/ImageView.html" target="_blank" rel="external">ImageView</a>关联的任务：</p>
<p>private static BitmapWorkerTask getBitmapWorkerTask(ImageView imageView) {<br>&nbsp; &nbsp;if (imageView != null) {<br>&nbsp; &nbsp; &nbsp; &nbsp;final Drawable drawable = imageView.getDrawable();<br>&nbsp; &nbsp; &nbsp; &nbsp;if (drawable instanceof AsyncDrawable) {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;final AsyncDrawable asyncDrawable = (AsyncDrawable) drawable;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return asyncDrawable.getBitmapWorkerTask();<br>&nbsp; &nbsp; &nbsp; &nbsp;}<br>&nbsp; &nbsp; }<br>&nbsp; &nbsp; return null;<br>}</p>
<p>最后一步是在<code>[BitmapWorkerTask](http://developer.android.com/training/displaying-bitmaps/process-bitmap.html#BitmapWorkerTask)&amp;nbsp;中</code>更新&nbsp;<code>onPostExecute()</code>&nbsp;方法，&nbsp;检查task是否被取消以及当前的task是否与跟ImageView关联的那个匹配：</p>
<p>class BitmapWorkerTask extends AsyncTask&lt;Integer, Void, Bitmap&gt; {<br>&nbsp; &nbsp; …</p>
<p>&nbsp; &nbsp; @Override<br>&nbsp; &nbsp; protected void onPostExecute(Bitmap bitmap) {<br>&nbsp; &nbsp; &nbsp; &nbsp; if (isCancelled()) {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bitmap = null;<br>&nbsp; &nbsp; &nbsp; &nbsp; }</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; if (imageViewReference != null &amp;&amp; bitmap != null) {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; final ImageView imageView = imageViewReference.get();<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; final BitmapWorkerTask bitmapWorkerTask =<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; getBitmapWorkerTask(imageView);<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (this == bitmapWorkerTask &amp;&amp; imageView != null) {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; imageView.setImageBitmap(bitmap);<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; }<br>}</p>
<p>这样的实现就也适用于&nbsp;<code>[ListView](http://developer.android.com/reference/android/widget/ListView.html)</code>&nbsp;和&nbsp;<a href="http://developer.android.com/reference/android/widget/GridView.html" target="_blank" rel="external">GridView</a>&nbsp;了，即使它们重用子View。&nbsp;只需要简单的在你为ImageView设置图片的地方调用一下&nbsp;loadBitmap&nbsp;方法。例如在ListView对应的Adapter的getView方法中调用。</p>
<pre><code>    作者：sweetvvck 发表于2014/10/31 23:41:35 [原文链接](http://blog.csdn.net/sweetvvck/article/details/40663987)


阅读：363 评论：0 [查看评论](http://blog.csdn.net/sweetvvck/article/details/40663987#comments)
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>如果图片源数据是从硬盘，网络或是其他非内存中读取的话，在<a href="http://developer.android.com/training/displaying-bitmaps/load-bitmap.html" target="_blank" rel="exte]]>
    </summary>
    
      <category term="Android" scheme="http://sweetvvck.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[译]Android学习路线（三十一）高效地加载大的Bitmap]]></title>
    <link href="http://sweetvvck.github.io/2014/10/31/%E8%AF%91-Android%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%EF%BC%88%E4%B8%89%E5%8D%81%E4%B8%80%EF%BC%89%E9%AB%98%E6%95%88%E5%9C%B0%E5%8A%A0%E8%BD%BD%E5%A4%A7%E7%9A%84Bitmap/"/>
    <id>http://sweetvvck.github.io/2014/10/31/译-Android学习路线（三十一）高效地加载大的Bitmap/</id>
    <published>2014-10-31T15:40:38.000Z</published>
    <updated>2016-01-25T20:06:53.000Z</updated>
    <content type="html"><![CDATA[<p>图片的大小形状千变万化。在很多情况下图片都比一个app的UI所需要展示的大小大很多。例如，系统的相册应用所展示的用系统相机拍摄的相片，这些相片比手机屏幕的分辨率大得多。</p>
<p>假设你的app所使用的内存有限制，理想情况下你只想要在内存中加载一个较低分辨率的图片。同事这个低分辨率的图片要匹配用来显示它的UI组件的大小。高分辨率的图片并不能带来任何可见的好处，但是仍然会消耗珍贵的内存同时还会导致额外的性能开销。</p>
<p>本课将会讲解如何在不溢出app内存限制的情况下通过在内存中加载小版本图片来解码大bitmaps。</p>
<h2 id="u8BFB_u53D6Bitmap_u7684_u5C3A_u5BF8_u548C_u7C7B_u578B"><a href="#u8BFB_u53D6Bitmap_u7684_u5C3A_u5BF8_u548C_u7C7B_u578B" class="headerlink" title="读取Bitmap的尺寸和类型"></a>读取Bitmap的尺寸和类型</h2><hr>
<p><a href="http://developer.android.com/reference/android/graphics/BitmapFactory.html" target="_blank" rel="external">BitmapFactory</a>&nbsp;类提供几种解码方法(<a href="http://developer.android.com/reference/android/graphics/BitmapFactory.html#decodeByteArray(byte[], int, int, android.graphics.BitmapFactory.Options" target="_blank" rel="external">decodeByteArray()</a>),&nbsp;<a href="http://developer.android.com/reference/android/graphics/BitmapFactory.html#decodeFile(java.lang.String, android.graphics.BitmapFactory.Options" target="_blank" rel="external">decodeFile()</a>),<a href="http://developer.android.com/reference/android/graphics/BitmapFactory.html#decodeResource(android.content.res.Resources, int, android.graphics.BitmapFactory.Options" target="_blank" rel="external">decodeResource()</a>),<br> 等等.)来通过多种多样的资源文件创建&nbsp;<a href="http://developer.android.com/reference/android/graphics/Bitmap.html" target="_blank" rel="external">Bitmap</a>&nbsp;。根据你的图片数据源选择一个最合适的解码方法。这些方法为bitmap分配内存，这样就很容易导致OutOfMemory&nbsp;异常。每种类型的解码方法都有额外的参数以让你通过<a href="http://developer.android.com/reference/android/graphics/BitmapFactory.Options.html" target="_blank" rel="external">BitmapFactory.Options</a>&nbsp;类指定解码的选项。在解码时设置<a href="http://developer.android.com/reference/android/graphics/BitmapFactory.Options.html#inJustDecodeBounds" target="_blank" rel="external">inJustDecodeBounds</a>&nbsp;属性为&nbsp;true&nbsp;能够避免内存分配，同时还能够获取到<a href="http://developer.android.com/reference/android/graphics/BitmapFactory.Options.html#outWidth" target="_blank" rel="external">outWidth</a>,&nbsp;<a href="http://developer.android.com/reference/android/graphics/BitmapFactory.Options.html#outHeight" target="_blank" rel="external">outHeight</a>&nbsp;和&nbsp;<a href="http://developer.android.com/reference/android/graphics/BitmapFactory.Options.html#outMimeType" target="_blank" rel="external">outMimeType</a>&nbsp;的&#20540;，此时解码方法返回的bitmap对象为null。这种发式允许你在构建这个bitmap（和内存分配）之前读取它的大小和类型。</p>
<p>BitmapFactory.Options options = new BitmapFactory.Options();<br>options.inJustDecodeBounds = true;<br>BitmapFactory.decodeResource(getResources(), R.id.myimage, options);<br>int imageHeight = options.outHeight;<br>int imageWidth = options.outWidth;<br>String imageType = options.outMimeType;</p>
<p>为了避免java.lang.OutOfMemory&nbsp;异常，可以在每次解码它之前取得它的尺寸，除非你完全肯定这个图片源的大小的消耗能够在可用内存之内。</p>
<h2 id="u5728_u5185_u5B58_u4E2D_u52A0_u8F7D_u56FE_u7247_u7684_u538B_u7F29_u7248_u672C"><a href="#u5728_u5185_u5B58_u4E2D_u52A0_u8F7D_u56FE_u7247_u7684_u538B_u7F29_u7248_u672C" class="headerlink" title="在内存中加载图片的压缩版本"></a>在内存中加载图片的压缩版本</h2><hr>
<p>现在图片的尺寸已经知道了，我们就能够决定是否加载原图还是图片的缩小版本。下面有几点需要考虑:</p>
<ul>
<li>预估加载完整图片所需的内存使用量。</li>
<li>你想要为加载此图片分配的内存的总量。</li>
<li>要载入的目标<a href="http://developer.android.com/reference/android/widget/ImageView.html" target="_blank" rel="external">ImageView</a>&nbsp;或者UI组件的尺寸。</li>
<li>当前设备的屏幕大小和密度。</li>
</ul>
<p>例如，如果一张图片要在一个ImageView中被展示成一个128x96像素的缩略图，那么加载一个1024x768 像素的图片进内存是完全不&#20540;得的。</p>
<p>告诉解码者压缩图片，加载一个压缩版图片进入内存，需要在<a href="http://developer.android.com/reference/android/graphics/BitmapFactory.Options.html" target="_blank" rel="external">BitmapFactory.Options</a>对象中设置&nbsp;<a href="http://developer.android.com/reference/android/graphics/BitmapFactory.Options.html#inSampleSize" target="_blank" rel="external">inSampleSize</a>&nbsp;为&nbsp;true。例如，一个图片，分辨率为&nbsp;2048x1536以&nbsp;<a href="http://developer.android.com/reference/android/graphics/BitmapFactory.Options.html#inSampleSize" target="_blank" rel="external">inSampleSize</a>&nbsp;＝<br> 4为参数被解码，将会产生一个分辨率大概为512x384的bitmap。加载它进内存只需要使用0.75MB 内存，而非加载完整图片所需的12MB (假定bitmap的配置为<a href="http://developer.android.com/reference/android/graphics/Bitmap.Config.html" target="_blank" rel="external">ARGB_8888</a>)。下面是一个基于目标长度和宽度计算压缩图片尺寸&#20540;的方法：</p>
<p>public static int calculateInSampleSize(<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; BitmapFactory.Options options, int reqWidth, int reqHeight) {<br>&nbsp; &nbsp; // Raw height and width of image<br>&nbsp; &nbsp; final int height = options.outHeight;<br>&nbsp; &nbsp; final int width = options.outWidth;<br>&nbsp; &nbsp; int inSampleSize = 1;</p>
<p>&nbsp; &nbsp; if (height &gt; reqHeight || width &gt; reqWidth) {</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; final int halfHeight = height / 2;<br>&nbsp; &nbsp; &nbsp; &nbsp; final int halfWidth = width / 2;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; // Calculate the largest inSampleSize value that is a power of 2 and keeps both<br>&nbsp; &nbsp; &nbsp; &nbsp; // height and width larger than the requested height and width.<br>&nbsp; &nbsp; &nbsp; &nbsp; while ((halfHeight / inSampleSize) &gt; reqHeight<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; (halfWidth / inSampleSize) &gt; reqWidth) {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; inSampleSize *= 2;<br>&nbsp; &nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; }</p>
<p>&nbsp; &nbsp; return inSampleSize;<br>}</p>
<p><strong>Note:</strong>&nbsp;A power of two value is calculated because the decoder uses a final value by rounding down to the nearest power of two, as per the&nbsp;<a href="http://developer.android.com/reference/android/graphics/BitmapFactory.Options.html#inSampleSize" target="_blank" rel="external">inSampleSize</a>&nbsp;documentation.</p>
<p>要使用这个方法，首先需要按照之前的方式获取图片的尺寸和类型，然后在通过计算出的&nbsp;<a href="http://developer.android.com/reference/android/graphics/BitmapFactory.Options.html#inSampleSize" target="_blank" rel="external">inSampleSize</a>&nbsp;&#20540;来生成bitmap：</p>
<p>public static Bitmap decodeSampledBitmapFromResource(Resources res, int resId,<br>&nbsp; &nbsp; &nbsp; &nbsp; int reqWidth, int reqHeight) {</p>
<p>&nbsp; &nbsp; // First decode with inJustDecodeBounds=true to check dimensions<br>&nbsp; &nbsp; final BitmapFactory.Options options = new BitmapFactory.Options();<br>&nbsp; &nbsp; options.inJustDecodeBounds = true;<br>&nbsp; &nbsp; BitmapFactory.decodeResource(res, resId, options);</p>
<p>&nbsp; &nbsp; // Calculate inSampleSize<br>&nbsp; &nbsp; options.inSampleSize = calculateInSampleSize(options, reqWidth, reqHeight);</p>
<p>&nbsp; &nbsp; // Decode bitmap with inSampleSize set<br>&nbsp; &nbsp; options.inJustDecodeBounds = false;<br>&nbsp; &nbsp; return BitmapFactory.decodeResource(res, resId, options);<br>}</p>
<p>下面这种方式很简单的实现了加载一个很大的图片到一个100x100像素缩略图的ImageView中：</p>
<p>mImageView.setImageBitmap(<br>&nbsp; &nbsp; decodeSampledBitmapFromResource(getResources(), R.id.myimage, 100, 100));</p>
<p>你也可以使用类&#20284;的流程从其他图片源中解码bitmap，根据需要使用适当的解码方法<a href="http://developer.android.com/reference/android/graphics/BitmapFactory.html#decodeByteArray(byte[], int, int, android.graphics.BitmapFactory.Options" target="_blank" rel="external">BitmapFactory.decode*</a>)&nbsp;。</p>
<pre><code>    作者：sweetvvck 发表于2014/10/31 23:40:38 [原文链接](http://blog.csdn.net/sweetvvck/article/details/40663965)


阅读：398 评论：0 [查看评论](http://blog.csdn.net/sweetvvck/article/details/40663965#comments)
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>图片的大小形状千变万化。在很多情况下图片都比一个app的UI所需要展示的大小大很多。例如，系统的相册应用所展示的用系统相机拍摄的相片，这些相片比手机屏幕的分辨率大得多。</p>
<p>假设你的app所使用的内存有限制，理想情况下你只想要在内存中加载一个较低分辨率的图片。同事]]>
    </summary>
    
      <category term="Android" scheme="http://sweetvvck.github.io/tags/Android/"/>
    
      <category term="Bitmap" scheme="http://sweetvvck.github.io/tags/Bitmap/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[译]Android学习路线（三十）高效地显示Bitmaps]]></title>
    <link href="http://sweetvvck.github.io/2014/10/31/%E8%AF%91-Android%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%EF%BC%88%E4%B8%89%E5%8D%81%EF%BC%89%E9%AB%98%E6%95%88%E5%9C%B0%E6%98%BE%E7%A4%BABitmaps/"/>
    <id>http://sweetvvck.github.io/2014/10/31/译-Android学习路线（三十）高效地显示Bitmaps/</id>
    <published>2014-10-31T15:39:24.000Z</published>
    <updated>2016-01-25T20:06:41.000Z</updated>
    <content type="html"><![CDATA[<p>学习如何使用常规的技术来加载<code>[Bitmap](http://developer.android.com/reference/android/graphics/Bitmap.html)</code>&nbsp;对象，保持你的UI灵敏，同时避免溢出应用内存限制。如果你不注意，bitmaps能够很快地消费你的可用内存预算，让你的app<br> crash掉，并且跑出下面这个可怕的异常：</p>
<p><code>java.lang.OutofMemoryError: bitmap size exceeds VM budget</code>.</p>
<p>下面有几个原因来说明在Android应用中加载bitmaps是很棘手的：</p>
<ul>
<li>移动设备的典型特征是系统资源有限。有些Android设备每个App可以小到仅有16M的可用内存。应用应该在这种内存限制下做优化。然而，很多设备已经可以配置到更高的限制。</li>
<li>Bitmaps占用了很多内存，特别是色彩丰富的图片，像照片。例如，&nbsp;<a href="http://www.android.com/devices/detail/galaxy-nexus" target="_blank" rel="external">Galaxy Nexus</a>&nbsp;中的相机照出的相片有2592x1936 像素 (5 百万像素)。如果这个bitmap使用的配置是&nbsp;<code>[ARGB_8888](http://developer.android.com/reference/android/graphics/Bitmap.Config.html)</code>&nbsp;(从Android2.3开始的默认配置)，那么加载这个图片到内存中需要占用19MB，这样马上就用光了某些设备的每个app的内存限制。</li>
<li>Android app UI会频繁的需要多个bitmaps的一次载入。像&nbsp;<code>[ListView](http://developer.android.com/reference/android/widget/ListView.html)</code>,<code>[GridView](http://developer.android.com/reference/android/widget/GridView.html)</code>&nbsp;以及&nbsp;<code>[ViewPager](http://developer.android.com/reference/android/support/v4/view/ViewPager.html)</code>&nbsp;这些组件通常都会一次在屏幕上显示多个bitmaps同时还会有更多的bitmaps在后台等待被显示。</li>
</ul>
<h2 id="u8BFE_u7A0B"><a href="#u8BFE_u7A0B" class="headerlink" title="课程"></a>课程</h2><hr>
<p><strong>高效地加载大Bitmaps</strong>此课程带你学习如何解码大bitmaps而不溢出app的内存限制。<strong>在非UI线程处理Bitmaps</strong>Bitmap处理(重置大小，从远端下载等等)都不应该在主UI线程中出现。此课程带你学习如何使用AsyncTask在后台线程中处理bitmaps，同时也会扩展一些处理并发的知识。<strong>缓存Bitmaps</strong>此课程教你使用内存和磁盘来缓存bitmap来提高你的UI加载大量图片时的响应速度和流畅性。<strong>管理Bitmap内存</strong>此课程想你解释如何管理bitmap内存来最优化你的app的表现。<strong>在你的UI中展示Bitmaps</strong>此课程将想你展示如何加载多个bitmaps到类&#20284;<code>[ViewPager](http://developer.android.com/reference/android/support/v4/view/ViewPager.html)</code>&nbsp;和&nbsp;<code>[GridView](http://developer.android.com/reference/android/widget/GridView.html)</code>&nbsp;的组件中，同时使用了后台线程和缓存。</p>
<pre><code>    作者：sweetvvck 发表于2014/10/31 23:39:24 [原文链接](http://blog.csdn.net/sweetvvck/article/details/40663905)


阅读：351 评论：0 [查看评论](http://blog.csdn.net/sweetvvck/article/details/40663905#comments)
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>学习如何使用常规的技术来加载<code>[Bitmap](http://developer.android.com/reference/android/graphics/Bitmap.html)</code>&nbsp;对象，保持你的UI灵敏，同时避免溢出应用内存限制。如果]]>
    </summary>
    
      <category term="Android" scheme="http://sweetvvck.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[译]Android学习路线（二十八）保存文件]]></title>
    <link href="http://sweetvvck.github.io/2014/09/30/%E8%AF%91-Android%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%EF%BC%88%E4%BA%8C%E5%8D%81%E5%85%AB%EF%BC%89%E4%BF%9D%E5%AD%98%E6%96%87%E4%BB%B6/"/>
    <id>http://sweetvvck.github.io/2014/09/30/译-Android学习路线（二十八）保存文件/</id>
    <published>2014-09-30T15:57:47.000Z</published>
    <updated>2016-01-25T20:06:19.000Z</updated>
    <content type="html"><![CDATA[<p>转载请注明出处：<a href="http://blog.csdn.net/sweetvvck/article/details/38645095" target="_blank" rel="external">Android学习路线（二十八）保存文件</a></p>
<p>Android使用了一个类&#20284;其他平台的基于磁盘的文件系统。本课将介绍如何使用android的文件APIS来在这样的文件系统中读写文件。</p>
<p>一个<a href="http://developer.android.com/reference/java/io/File.html" target="_blank" rel="external">File</a>&nbsp;对象适用于顺序读写大块数据，而不适用于随机存取。例如它适用于文件或者其他通过网络交换的数据。</p>
<p>本课将想您介绍如何在app中处理基本的文件操作。在此之前，你需要对Linux文件系统以及标准的java文件apis有所了解。</p>
<h2 id="u9009_u62E9_u5185_u90E8_u6216_u5916_u90E8_u5B58_u50A8"><a href="#u9009_u62E9_u5185_u90E8_u6216_u5916_u90E8_u5B58_u50A8" class="headerlink" title="选择内部或外部存储"></a>选择内部或外部存储</h2><hr>
<p>所有的Android设备都由两个存储区域：“内部”和“外部”存储。这两个名字来源于早期的android版本，当时大多数设备提供“内部构建”（built-in）不可拆卸的内部存储，以及可拆卸的存储媒介，例如微型SD卡。一些设备也将持久化存储设备分为“内部”和“外部”两个部分，因此即使是没有可拆卸媒介的设备也会有两个存储区域，而API的行为与设备是否有可拆卸存储介质无关，下面总结了每个存储区域的相关要点。</p>
<p><strong>内部存储：</strong></p>
<ul>
<li>任何时候都可用。</li>
<li>默认情况下只有在你的app中才能访问。</li>
<li>当用户卸载你的app，系统将移除该应用在内部存储中的所有文件。</li>
</ul>
<p>当你确定用户和其他app都不能访问到的情况下，内部存储是最佳选择。</p>
<p><strong>外部存储：</strong></p>
<ul>
<li>它并不是任何时候都可用，因为用户能够像U盘一样使用它，同时它也可能随时被从设备上移除。</li>
<li>它能被任何人访问，因此存储在这里的文件能够被其他app读取。</li>
<li>当用户卸载你的app，系统只会在你将文件保存在<a href="http://developer.android.com/reference/android/content/Context.html#getExternalFilesDir(java.lang.String" target="_blank" rel="external">getExternalFilesDir()</a>)&nbsp;中时才会在这里移除你app中的文件。</li>
</ul>
<p>当你不需要控制文件的访问权限，同时你希望将文件和其他应用共享或者能够在电脑中访问到，那么外部存储是最好的选择。</p>
<p><strong>提示:</strong>&nbsp;即使是apps默认会被安装在内部存储中，你也可以在你的app中的manifest文件中指定<a href="http://developer.android.com/guide/topics/manifest/manifest-element.html#install" target="_blank" rel="external">android:installLocation</a>&nbsp;属性，让你的app被安装在外部存储中。当apk的大小很大时，用户会非常希望这么做，他们会有一个远大于内部存储的外部存储空间。更多信息，请参阅<a href="http://developer.android.com/guide/topics/data/install-location.html" target="_blank" rel="external">App<br> Install Location</a>。</p>
<h2 id="u83B7_u53D6_u5916_u90E8_u5B58_u50A8_u6743_u9650"><a href="#u83B7_u53D6_u5916_u90E8_u5B58_u50A8_u6743_u9650" class="headerlink" title="获取外部存储权限"></a>获取外部存储权限</h2><hr>
<p>要能够在外部存储中写文件，你必须在manifest文件中申请&nbsp;<a href="http://developer.android.com/reference/android/Manifest.permission.html#WRITE_EXTERNAL_STORAGE" target="_blank" rel="external">WRITE_EXTERNAL_STORAGE</a>&nbsp;权限：</p>
<p>&lt;manifest …&gt;<br>&nbsp; &nbsp; &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt;<br>&nbsp; &nbsp; …<br>&lt;/manifest&gt;</p>
<p><strong>注意:</strong>&nbsp;目前，所有的应用都有权限读取外部存储中的文件。然而，在之后的版本中将会改变。如果你的app需要读取外部存储中的文件（但是不需要写入），你需要声明<a href="http://developer.android.com/reference/android/Manifest.permission.html#READ_EXTERNAL_STORAGE" target="_blank" rel="external">READ_EXTERNAL_STORAGE</a>&nbsp;权限。这样来保证你的app能够像预期那样工作。</p>
<p>&lt;manifest …&gt;<br>&nbsp; &nbsp; &lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot; /&gt;<br>&nbsp; &nbsp; …<br>&lt;/manifest&gt;</p>
<p>然而，如果你的app使用了<a href="http://developer.android.com/reference/android/Manifest.permission.html#WRITE_EXTERNAL_STORAGE" target="_blank" rel="external">WRITE_EXTERNAL_STORAGE</a>&nbsp;权限，那么它就同时拥有了读写权限。</p>
<p>保存文件到内部存储中并不需要权限。你的app一直拥有在内部存储目录下的读写权限。</p>
<h2 id="u4FDD_u5B58_u4E00_u4E2A_u6587_u4EF6_u5230_u5185_u90E8_u5B58_u50A8_u4E2D"><a href="#u4FDD_u5B58_u4E00_u4E2A_u6587_u4EF6_u5230_u5185_u90E8_u5B58_u50A8_u4E2D" class="headerlink" title="保存一个文件到内部存储中"></a>保存一个文件到内部存储中</h2><hr>
<p>当保存文件到内部存储中时，你可以通过下面这两种方式获取一个合适的File对象：</p>
<p><a href="http://developer.android.com/reference/android/content/Context.html#getFilesDir(" target="_blank" rel="external">getFilesDir()</a>)返回一个表示你的app在内部存储中的目录的<a href="http://developer.android.com/reference/java/io/File.html" target="_blank" rel="external">File</a>&nbsp;对象。<a href="http://developer.android.com/reference/android/content/Context.html#getCacheDir(" target="_blank" rel="external">getCacheDir()</a>)返回一个表示你的app在内部存储中的临时目录的<a href="http://developer.android.com/reference/java/io/File.html" target="_blank" rel="external">File</a>&nbsp;对象。确保在你不需要该缓存文件时将其删掉，同时要指定一个合理的缓存文件大小限制，因为当系统缺少运行空间时会在不发出警告的情况下将该目录的文件删除。</p>
<p>要在上面两个目录之一中创建一个文件，你可以使用&nbsp;<a href="http://developer.android.com/reference/java/io/File.html#File(java.io.File, java.lang.String" target="_blank" rel="external">File()</a>)&nbsp;构造方法，传入前面获取到的File对象作为内部存储的目录。例如：</p>
<p>File file = new File(context.getFilesDir(), filename);</p>
<p>同样的，你还可以调用&nbsp;<a href="http://developer.android.com/reference/android/content/Context.html#openFileOutput(java.lang.String, int" target="_blank" rel="external">openFileOutput()</a>)&nbsp;方法来获取一个&nbsp;<a href="http://developer.android.com/reference/java/io/FileOutputStream.html" target="_blank" rel="external">FileOutputStream</a>&nbsp;，用于在你的内部存储中写入一个文件。例如，下面是如果像文件中写入一些文本：</p>
<p>String filename = &quot;myfile&quot;;<br>String string = &quot;Hello world!&quot;;<br>FileOutputStream outputStream;</p>
<p>try {<br>&nbsp; outputStream = openFileOutput(filename, Context.MODE_PRIVATE);<br>&nbsp; outputStream.write(string.getBytes());<br>&nbsp; outputStream.close();<br>} catch (Exception e) {<br>&nbsp; e.printStackTrace();<br>}</p>
<p>再或者，如果你需要缓存一些文件，你应该使用<a href="http://developer.android.com/reference/java/io/File.html#createTempFile(java.lang.String, java.lang.String" target="_blank" rel="external">createTempFile()</a>)。例如，下面的方法通过URL萃取文件名，同时使用这个文件名在内部缓存目录下创建一个文件：</p>
<p>public File getTempFile(Context context, String url) {<br>&nbsp; &nbsp; File file;<br>&nbsp; &nbsp; try {<br>&nbsp; &nbsp; &nbsp; &nbsp; String fileName = Uri.parse(url).getLastPathSegment();<br>&nbsp; &nbsp; &nbsp; &nbsp; file = File.createTempFile(fileName, null, context.getCacheDir());<br>&nbsp; &nbsp; catch (IOException e) {<br>&nbsp; &nbsp; &nbsp; &nbsp; // Error while creating file<br>&nbsp; &nbsp; }<br>&nbsp; &nbsp; return file;<br>}</p>
<p><strong>提示:</strong>&nbsp;你的app的内部存储目录是由你的app包名指定。从技术上来说，如果你把这个文件的模式设置为可读，那么其他app就能够访问你的app的内部文件了。然而，这些其他的app必须知道你的app的包名以及内部文件的名字。如果你不特别地自定内部文件的可读或可写模式，那么别的应用也没有权限操作你的app中的内部文件。</p>
<h2 id="u4FDD_u5B58_u4E00_u4E2A_u6587_u4EF6_u5230_u5916_u90E8_u5B58_u50A8"><a href="#u4FDD_u5B58_u4E00_u4E2A_u6587_u4EF6_u5230_u5916_u90E8_u5B58_u50A8" class="headerlink" title="保存一个文件到外部存储"></a>保存一个文件到外部存储</h2><hr>
<p>由于外部存储可以不可用——例如当用户将其移除——你需要在访问它之前判断它是否可用。你可以通过调用<a href="http://developer.android.com/reference/android/os/Environment.html#getExternalStorageState(" target="_blank" rel="external">getExternalStorageState()</a>)方法查询到它的可用状态。如果该方法返回的状态等于<a href="http://developer.android.com/reference/android/os/Environment.html#MEDIA_MOUNTED" target="_blank" rel="external">MEDIA_MOUNTED</a>，那么你就能够读写你的文件。例如，下面的方法可用于判断外部存储是否可用：</p>
<p>/<em> Checks if external storage is available for read and write </em>/<br>public boolean isExternalStorageWritable() {<br>&nbsp; &nbsp; String state = Environment.getExternalStorageState();<br>&nbsp; &nbsp; if (Environment.MEDIA_MOUNTED.equals(state)) {<br>&nbsp; &nbsp; &nbsp; &nbsp; return true;<br>&nbsp; &nbsp; }<br>&nbsp; &nbsp; return false;<br>}</p>
<p>/<em> Checks if external storage is available to at least read </em>/<br>public boolean isExternalStorageReadable() {<br>&nbsp; &nbsp; String state = Environment.getExternalStorageState();<br>&nbsp; &nbsp; if (Environment.MEDIA_MOUNTED.equals(state) ||<br>&nbsp; &nbsp; &nbsp; &nbsp; Environment.MEDIA_MOUNTED_READ_ONLY.equals(state)) {<br>&nbsp; &nbsp; &nbsp; &nbsp; return true;<br>&nbsp; &nbsp; }<br>&nbsp; &nbsp; return false;<br>}</p>
<p>即使外部存储中的文件可以被用户或者其他app修改，对于下面两种类型的文件同样有合适的情况被保存在这里：</p>
<p>公共文件需要被所有app或者用户访问到的文件。当你卸载你的app，你希望用户留下这些文件。</p>
<p>例如，你的app拍下的照片或者其他下载文件。</p>
<p>私有文件文件隶属于你的app，并且应道在用户写在你的app是被删除。即使是这些文件在技术上来讲能够被用户或者其他app访问，实际上它在你的app外部是不会提供任何数据的。当你的app被卸载，系统将会删除你的app在外部存储中的所有私有目录。</p>
<p>例如，通过你的app下载的资源，或者临时的多媒体文件。</p>
<p>如果你希望在外部存储中保存公有文件，使用&nbsp;<a href="http://developer.android.com/reference/android/os/Environment.html#getExternalStoragePublicDirectory(java.lang.String" target="_blank" rel="external">getExternalStoragePublicDirectory()</a>)&nbsp;方法来获得一个&nbsp;<a href="http://developer.android.com/reference/java/io/File.html" target="_blank" rel="external">File</a>&nbsp;对象。这个方法会接收一个参数作为对应文件类型要存放的位置。例如<a href="http://developer.android.com/reference/android/os/Environment.html#DIRECTORY_MUSIC" target="_blank" rel="external">DIRECTORY_MUSIC</a>&nbsp;或者&nbsp;<a href="http://developer.android.com/reference/android/os/Environment.html#DIRECTORY_PICTURES" target="_blank" rel="external">DIRECTORY_PICTURES</a></p>
<p>public File getAlbumStorageDir(String albumName) {<br>&nbsp; &nbsp; // Get the directory for the user’s public pictures directory.<br>&nbsp; &nbsp; File file = new File(Environment.getExternalStoragePublicDirectory(<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Environment.DIRECTORY_PICTURES), albumName);<br>&nbsp; &nbsp; if (!file.mkdirs()) {<br>&nbsp; &nbsp; &nbsp; &nbsp; Log.e(LOG_TAG, &quot;Directory not created&quot;);<br>&nbsp; &nbsp; }<br>&nbsp; &nbsp; return file;<br>}</p>
<p>如果你想要在外部存储中保存私有文件，那么你可以通过调用<a href="http://developer.android.com/reference/android/content/Context.html#getExternalFilesDir(java.lang.String" target="_blank" rel="external">getExternalFilesDir()</a>)&nbsp;方法来获取合适的文件目录对象，同时传入一个名字来指定目录的类型。每个通过这种方式调用获得的目录，都会在应用被卸载时被清除。</p>
<p>例如，下面是如何创建一个独立的相册目录：</p>
<p>public File getAlbumStorageDir(Context context, String albumName) {<br>&nbsp; &nbsp; // Get the directory for the app’s private pictures directory.<br>&nbsp; &nbsp; File file = new File(context.getExternalFilesDir(<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Environment.DIRECTORY_PICTURES), albumName);<br>&nbsp; &nbsp; if (!file.mkdirs()) {<br>&nbsp; &nbsp; &nbsp; &nbsp; Log.e(LOG_TAG, &quot;Directory not created&quot;);<br>&nbsp; &nbsp; }<br>&nbsp; &nbsp; return file;<br>}</p>
<p>如果没有合适的预定义的子目录名字适合你的文件，你可以调用&nbsp;<a href="http://developer.android.com/reference/android/content/Context.html#getExternalFilesDir(java.lang.String" target="_blank" rel="external">getExternalFilesDir()</a>)&nbsp;方法，同时传入null。它会返回外部存储中你的app对应的私有目录。</p>
<p>要记住通过&nbsp;<a href="http://developer.android.com/reference/android/content/Context.html#getExternalFilesDir(java.lang.String" target="_blank" rel="external">getExternalFilesDir()</a>)&nbsp;方法创建的目录将会在app卸载时被删除。如果这些文件需要在应用卸载后被保存，当你的应用再次安装时能够访问到，你需要调用<a href="http://developer.android.com/reference/android/os/Environment.html#getExternalStoragePublicDirectory(java.lang.String" target="_blank" rel="external">getExternalStoragePublicDirectory()</a>)方法。</p>
<p>不管你使用的是可分享的<a href="http://developer.android.com/reference/android/os/Environment.html#getExternalStoragePublicDirectory(java.lang.String" target="_blank" rel="external">getExternalStoragePublicDirectory()</a>)&nbsp;方法，或者是私有的<a href="http://developer.android.com/reference/android/content/Context.html#getExternalFilesDir(java.lang.String" target="_blank" rel="external">getExternalFilesDir()</a>)&nbsp;方法，使用系统所提供的目录名称（如&nbsp;<a href="http://developer.android.com/reference/android/os/Environment.html#DIRECTORY_PICTURES" target="_blank" rel="external">DIRECTORY_PICTURES</a>）都很重要。这些目录名称将确保这些文件在系统中会被按照这些方式对待。例如，保存在<a href="http://developer.android.com/reference/android/os/Environment.html#DIRECTORY_RINGTONES" target="_blank" rel="external">DIRECTORY_RINGTONES</a>&nbsp;中的文件将会被系统识别为手机铃声而非音乐。</p>
<h2 id="u67E5_u8BE2_u5269_u4F59_u7A7A_u95F4"><a href="#u67E5_u8BE2_u5269_u4F59_u7A7A_u95F4" class="headerlink" title="查询剩余空间"></a>查询剩余空间</h2><hr>
<p>如果你知道你要保存的数据的大小，这样你就可以判断出是否有足够的空间避免导致&nbsp;<a href="http://developer.android.com/reference/java/io/IOException.html" target="_blank" rel="external">IOException</a>&nbsp;异常，可通过调用<a href="http://developer.android.com/reference/java/io/File.html#getFreeSpace(" target="_blank" rel="external">getFreeSpace()</a>)&nbsp;或者&nbsp;<a href="http://developer.android.com/reference/java/io/File.html#getTotalSpace(" target="_blank" rel="external">getTotalSpace()</a>)方法来获取剩余空间的大小。这两个方法各自返回此时的可用空间大侠和存储卷中总共的空间大小。这个方法同样可以在开始就避免占满整个存储空间。</p>
<p>然而，系统并不能确保你能够写入通过<a href="http://developer.android.com/reference/java/io/File.html#getFreeSpace(" target="_blank" rel="external">getFreeSpace()</a>)方法返回的数据大小。如果它返回的大小比你要写入的数据大小大几兆，或者文件系统还有90%的剩余空间，那么执行保存是安全的。否则，你不应该存储这些数据。</p>
<p><strong>提示:</strong>&nbsp;在存储文件前检查可用空间不是必须操作。你可以直接保存文件，然后捕获<a href="http://developer.android.com/reference/java/io/IOException.html" target="_blank" rel="external">IOException</a>&nbsp;异常。你可以在你不知道要保存的数据有多大时使用这种方法。例如，你在保存文件前将PNG转变成JPEG，改变了文件的编码，你提前并不知道文件的大小。</p>
<h2 id="u5220_u9664_u4E00_u4E2A_u6587_u4EF6"><a href="#u5220_u9664_u4E00_u4E2A_u6587_u4EF6" class="headerlink" title="删除一个文件"></a>删除一个文件</h2><hr>
<p>你要记得在文件不需要被使用时将其删除。最直接的删除方法调用文件对象的<a href="http://developer.android.com/reference/java/io/File.html#delete(" target="_blank" rel="external">delete()</a>)&nbsp;方法删除它本身。</p>
<p>myFile.delete();</p>
<p>如果文件被保存在内部存储中，你同样可以使用Context定位然后调用<a href="http://developer.android.com/reference/android/content/Context.html#deleteFile(java.lang.String" target="_blank" rel="external">deleteFile()</a>)方法删除文件：</p>
<p>myContext.deleteFile(fileName);</p>
<p><strong>提示:</strong>&nbsp;当用户卸载你的app，系统将会删除下面内容：</p>
<ul>
<li>所有你的app保存在内部存储中的数据</li>
<li>所有通过调用<a href="http://developer.android.com/reference/android/content/Context.html#getExternalFilesDir(java.lang.String" target="_blank" rel="external">getExternalFilesDir()</a>)方法保存在外部存储中的数据。</li>
</ul>
<p>然而，你手动删除通过<a href="http://developer.android.com/reference/android/content/Context.html#getCacheDir(" target="_blank" rel="external">getCacheDir()</a>)&nbsp;方法生成的文件，当这些文件不再需要被使用到时。</p>
<pre><code>    作者：sweetvvck 发表于2014/9/30 23:57:47 [原文链接](http://blog.csdn.net/sweetvvck/article/details/38645095)


阅读：582 评论：0 [查看评论](http://blog.csdn.net/sweetvvck/article/details/38645095#comments)
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>转载请注明出处：<a href="http://blog.csdn.net/sweetvvck/article/details/38645095" target="_blank" rel="external">Android学习路线（二十八）保存文件</a></p>
<p>]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[[译]Android学习路线（二十六）Android数据存储]]></title>
    <link href="http://sweetvvck.github.io/2014/09/30/%E8%AF%91-Android%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%EF%BC%88%E4%BA%8C%E5%8D%81%E5%85%AD%EF%BC%89Android%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"/>
    <id>http://sweetvvck.github.io/2014/09/30/译-Android学习路线（二十六）Android数据存储/</id>
    <published>2014-09-30T15:56:52.000Z</published>
    <updated>2016-01-25T20:06:30.000Z</updated>
    <content type="html"><![CDATA[<p>大部分的Android应用都需要保存数据，甚至是为了让用户在&nbsp;<a href="http://developer.android.com/reference/android/app/Activity.html#onPause(" target="_blank" rel="external">onPause()</a>)&nbsp;时不至于丢失数据都需要保存信息。大多数一般的app同样需要保存用户设置的数据，而一些app则必须在文件或是数据库中管理大量的账号信息。本课将向你介绍Android中数据存储的主要方式，包括：</p>
<ul>
<li>使用shared preferences文件通过键&#20540;对保存简单数据类型</li>
<li>保存任意的文件到Android的文件系统中</li>
<li>使用SQLite数据库</li>
</ul>
<h2 id="u8BFE_u7A0B"><a href="#u8BFE_u7A0B" class="headerlink" title="课程"></a>课程</h2><hr>
<p><strong><a href="http://developer.android.com/training/basics/data-storage/shared-preferences.html" target="_blank" rel="external">保存键&#20540;对集合</a></strong>学习使用shared preferences文件来通过键&#20540;对方式存储少量数据。<strong><a href="http://developer.android.com/training/basics/data-storage/files.html" target="_blank" rel="external">保存文件</a></strong>学习保存一个基本到文件，例如存储一个长序列并且通常会被顺序读取的数据。<strong><a href="http://developer.android.com/training/basics/data-storage/databases.html" target="_blank" rel="external">保存数据到数据库</a></strong>学习使用SQLite数据库读写结构化数据。</p>
<pre><code>    作者：sweetvvck 发表于2014/9/30 23:56:52 [原文链接](http://blog.csdn.net/sweetvvck/article/details/38645041)


阅读：482 评论：0 [查看评论](http://blog.csdn.net/sweetvvck/article/details/38645041#comments)
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>大部分的Android应用都需要保存数据，甚至是为了让用户在&nbsp;<a href="http://developer.android.com/reference/android/app/Activity.html#onPause(" target="_blank" r]]>
    </summary>
    
      <category term="Android" scheme="http://sweetvvck.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[译]Android学习路线（二十七）键值对（SharedPreferences）存储]]></title>
    <link href="http://sweetvvck.github.io/2014/09/30/%E8%AF%91-Android%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%83%EF%BC%89%E9%94%AE%E5%80%BC%E5%AF%B9%EF%BC%88SharedPreferences%EF%BC%89%E5%AD%98%E5%82%A8/"/>
    <id>http://sweetvvck.github.io/2014/09/30/译-Android学习路线（二十七）键值对（SharedPreferences）存储/</id>
    <published>2014-09-30T15:56:29.000Z</published>
    <updated>2016-01-25T20:06:34.000Z</updated>
    <content type="html"><![CDATA[<p>如果你又一个相对较小的键&#20540;对数据想要保存，你应该使用<a href="http://developer.android.com/reference/android/content/SharedPreferences.html" target="_blank" rel="external">SharedPreferences</a>&nbsp;APIs。一个<a href="http://developer.android.com/reference/android/content/SharedPreferences.html" target="_blank" rel="external">SharedPreferences</a>&nbsp;对象指向一个包含键&#20540;对的文件，它提供简单的方法来读写他们。每个<a href="http://developer.android.com/reference/android/content/SharedPreferences.html" target="_blank" rel="external">SharedPreferences</a>&nbsp;文件系统框架管理，它们可以是私有的也可以被共享。</p>
<p>本课将介绍如何使用<a href="http://developer.android.com/reference/android/content/SharedPreferences.html" target="_blank" rel="external">SharedPreferences</a>&nbsp;APIs来存储和获取简单的数据。</p>
<p><strong>提示:</strong>&nbsp;<a href="http://developer.android.com/reference/android/content/SharedPreferences.html" target="_blank" rel="external">SharedPreferences</a>&nbsp;APIs<br> 只能被用来操作键&#20540;对类型数据，不要把它和&nbsp;<a href="http://developer.android.com/reference/android/preference/Preference.html" target="_blank" rel="external">Preference</a>&nbsp;APIs弄混淆，Preference是用来帮助用户构建app设置界面的。更多关于&nbsp;<a href="http://developer.android.com/reference/android/preference/Preference.html" target="_blank" rel="external">Preference</a>&nbsp;APIs的信息，请移步<a href="http://developer.android.com/guide/topics/ui/settings.html" target="_blank" rel="external">Settings</a>&nbsp;向导。</p>
<h2 id="u83B7_u53D6SharedPreferences_u7684_u5F15_u7528_uFF08_u53E5_u67C4_uFF09"><a href="#u83B7_u53D6SharedPreferences_u7684_u5F15_u7528_uFF08_u53E5_u67C4_uFF09" class="headerlink" title="获取SharedPreferences的引用（句柄）"></a>获取SharedPreferences的引用（句柄）</h2><p>你可以通过下面任意一种方式创建一个新的shared preference文件或者访问一个已经存在的shared preference文件：</p>
<ul>
<li><a href="http://developer.android.com/reference/android/content/Context.html#getSharedPreferences(java.lang.String, int" target="_blank" rel="external">getSharedPreferences()</a>)&nbsp;—<br>Use this if you need multiple shared preference files identified by name, which you specify with the first parameter. You can call this from any&nbsp;<a href="http://developer.android.com/reference/android/content/Context.html" target="_blank" rel="external">Context</a>&nbsp;in<br>your app.</li>
<li><p><a href="http://developer.android.com/reference/android/content/Context.html#getSharedPreferences(java.lang.String, int" target="_blank" rel="external">getSharedPreferences()</a>)&nbsp;—<br>如果你通过不同的名字保存了多个shared preference文件，那么你可以使用这个方法，这个方法的第一个参数即为文件名。你可以在应用中使用Context对象来调用它。</p>
</li>
<li><p><a href="http://developer.android.com/reference/android/app/Activity.html#getPreferences(int" target="_blank" rel="external">getPreferences()</a>)&nbsp;—<br>如果你只需要在这个activity中使用一个shared preference文件，那么你可以在activity中调用这个方法。因为这个方法会返回属于这个activity的一个默认的shared preference文件，你不需要为它提供一个名字。</p>
</li>
</ul>
<p>例如，以下的方法会在 &nbsp;<a href="http://developer.android.com/reference/android/app/Fragment.html" target="_blank" rel="external">Fragment</a>&nbsp;中被执行。它在内部访问了一个shared<br> preferences文件，这个文件被&nbsp;R.string.preference_file_key&nbsp;这个字符串指定，并且它是被私有模式（private mode）打开的，因此只能被你的app访问。</p>
<p>Context context = getActivity();<br>SharedPreferences sharedPref = context.getSharedPreferences(<br>&nbsp; &nbsp; &nbsp; &nbsp; getString(R.string.preference_file_key), Context.MODE_PRIVATE);</p>
<p>当为你的shared preference文件命名时，你应当使用一个唯一的标识，例如&quot;com.example.myapp.PREFERENCE_FILE_KEY&quot;</p>
<p>作为替代，如果你只想要在你的activity中使用一个shared preference文件，你可以使用&nbsp;<a href="http://developer.android.com/reference/android/app/Activity.html#getPreferences(int" target="_blank" rel="external">getPreferences()</a>)方法：</p>
<p>SharedPreferences sharedPref = getActivity().getPreferences(Context.MODE_PRIVATE);</p>
<p><strong>注意:</strong>&nbsp;如果你使用&nbsp;<a href="http://developer.android.com/reference/android/content/Context.html#MODE_WORLD_READABLE" target="_blank" rel="external">MODE_WORLD_READABLE</a>&nbsp;或者&nbsp;<a href="http://developer.android.com/reference/android/content/Context.html#MODE_WORLD_WRITEABLE" target="_blank" rel="external">MODE_WORLD_WRITEABLE</a>模式创建了一个shared<br> preference文件，那么任何其他知道这个文件标识的app都能够访问到你的数据。</p>
<h2 id="u5411Shared_Preferences_u4E2D_u5199_u5165_u6570_u636E"><a href="#u5411Shared_Preferences_u4E2D_u5199_u5165_u6570_u636E" class="headerlink" title="向Shared Preferences中写入数据"></a>向Shared Preferences中写入数据</h2><hr>
<p>要向shared preferences文件中写入数据，你需要调用SharedPreferences的edit()方法来创建一个<a href="http://developer.android.com/reference/android/content/SharedPreferences.Editor.html" target="_blank" rel="external">SharedPreferences.Editor</a>&nbsp;对象。</p>
<p>传入键和&#20540;给你想要调用的方法，例如&nbsp;<a href="http://developer.android.com/reference/android/content/SharedPreferences.Editor.html#putInt" target="_blank" rel="external">putInt()</a>&amp;<a href="http://developer.android.com/reference/android/content/SharedPreferences.Editor.html#putStringjava.lang.String, java.lang.String" target="_blank" rel="external">putString()</a>。然后调用<a href="http://developer.android.com/reference/android/content/SharedPreferences.Editor.html#commit(" target="_blank" rel="external">commit()</a>)&nbsp;方法来存储这些改变。例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SharedPreferences sharedPref = getActivity().getPreferences(Context.MODE_PRIVATE);</span><br><span class="line">SharedPreferences.Editor editor = sharedPref.edit();</span><br><span class="line">editor.putInt(getString(R.string.saved_high_score), newHighScore);</span><br><span class="line">editor.commit();</span><br></pre></td></tr></table></figure></p>
<h2 id="u4ECEShared_Preferences_u4E2D_u8BFB_u53D6_u6570_u636E"><a href="#u4ECEShared_Preferences_u4E2D_u8BFB_u53D6_u6570_u636E" class="headerlink" title="从Shared Preferences中读取数据"></a>从Shared Preferences中读取数据</h2><hr>
<p>要从shared preferences文件中获取数据，可以调用getInt()或者getString()等方法，只需要提供你想要获得的&#20540;对应的key就可以了；你也可以选择再传入一个默认&#20540;，如果通过传入的key没有取道&#20540;将会返回这个默认&#20540;。例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SharedPreferences sharedPref = getActivity().getPreferences(Context.MODE_PRIVATE);</span><br><span class="line"><span class="keyword">int</span> defaultValue = getResources().getInteger(R.string.saved_high_score_default);</span><br><span class="line"><span class="keyword">long</span> highScore = sharedPref.getInt(getString(R.string.saved_high_score), defaultValue);</span><br></pre></td></tr></table></figure></p>
<pre><code>    作者：sweetvvck 发表于2014/9/30 23:56:29 [原文链接](http://blog.csdn.net/sweetvvck/article/details/38645065)


阅读：765 评论：0 [查看评论](http://blog.csdn.net/sweetvvck/article/details/38645065#comments)
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>如果你又一个相对较小的键&#20540;对数据想要保存，你应该使用<a href="http://developer.android.com/reference/android/content/SharedPreferences.html" target="_blank" ]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[[译]Android学习路线（二十九）保存数据到SQLite中]]></title>
    <link href="http://sweetvvck.github.io/2014/09/30/%E8%AF%91-Android%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B9%9D%EF%BC%89%E4%BF%9D%E5%AD%98%E6%95%B0%E6%8D%AE%E5%88%B0SQLite%E4%B8%AD/"/>
    <id>http://sweetvvck.github.io/2014/09/30/译-Android学习路线（二十九）保存数据到SQLite中/</id>
    <published>2014-09-30T15:55:32.000Z</published>
    <updated>2016-01-25T19:44:12.000Z</updated>
    <content type="html"><![CDATA[<p>对于可复用或者结构化的数据来说，把它们存储到数据库中是理想的方式。学习本课前你需要对通常的数据库有所了解，本课在此前提下会帮助你学习如何在android系统中操作SQLite数据库。你需要使用到的APIs都可以在<a href="http://developer.android.com/reference/android/database/sqlite/package-summary.html" target="_blank" rel="external">android.database.sqlite</a> 包中访问到。</p>
<p>定义一个&#26684;式和契约</p>
<p>SQL数据库最主要的标准之一是其&#26684;式（Schema）：它用来声明数据库的组织。Schema可以通过你用来创建数据库的语句来表示。你会发现创建一个能够有条理地，明确指定schema布局的 “伙伴 “类(也被称为 “关系类 “)是非常有帮助的。</p>
<p>关系类其实就是个定义常量的容器，这些常量包含URIs,tables以及colums的名称。这个关系类允许你在同一个包下的所有类中都能够访问。这样的话，你只要在这里改变一个列名，你的所有代码都会受影响。</p>
<p>一个好的组织关系类的方法是，让你的关系类中对于整个数据库来说是全局可用的常量定义在关系类的顶级，然后为每个表在该类中建立内部类。</p>
<p><strong>提示:</strong> 通过实现 <a href="http://developer.android.com/reference/android/provider/BaseColumns.html" target="_blank" rel="external">BaseColumns</a> 接口，你的内部类能够继承一个名称为_ID的属性，它在默写类(例如cursor<br> adapter)中被期望存在。它不是必须的，但是如果它的存在能够让你的数据库和Android框架相处更加和谐。</p>
<p>例如，下面的代码片段定义了一个表的表明和列名：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FeedReaderContract</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// To prevent someone from accidentally instantiating the contract class,</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// give it an empty constructor.</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FeedReaderContract</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Inner class that defines the table contents */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">FeedEntry</span> <span class="keyword">implements</span> <span class="title">BaseColumns</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TABLE_NAME = <span class="string">"entry "</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String COLUMN_NAME_ENTRY_ID = <span class="string">"entryid "</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String COLUMN_NAME_TITLE = <span class="string">"title "</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String COLUMN_NAME_SUBTITLE = <span class="string">"subtitle "</span>;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">通过SQL Helper创建一个数据库</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">一旦你定义了你的数据库的样子，你就需要实现一些方法来创建和保持数据库和表。下面是创建和删除一个表的典型的语句：</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span></span><br><span class="line"><span class="keyword">final</span> String TEXT_TYPE = <span class="string">"TEXT"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String COMMA_SEP = <span class="string">","</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SQL_CREATE_ENTRIES =  </span><br><span class="line">	<span class="string">"CREATE TABLE"</span></span><br><span class="line">	+ FeedEntry.TABLE_NAME</span><br><span class="line">	+ <span class="string">" ( "</span></span><br><span class="line">	+ FeedEntry._ID</span><br><span class="line">	+ <span class="string">"INTEGER PRIMARY KEY,"</span></span><br><span class="line">	+ FeedEntry.COLUMN_NAME_ENTRY_ID</span><br><span class="line">	+ <span class="string">"TEXT_TYPE  ; COMMA_SEP"</span></span><br><span class="line">	+ FeedEntry.COLUMN_NAME_TITLE</span><br><span class="line">	+ <span class="string">"TEXT_TYPE  ; COMMA_SEP"</span></span><br><span class="line"></span><br><span class="line">    ... <span class="comment">// Any other options for the CREATE command</span></span><br><span class="line"></span><br><span class="line">     <span class="string">" ) "</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span></span><br><span class="line"><span class="keyword">final</span> String SQL_DELETE_ENTRIES</span><br><span class="line">= <span class="string">"DROP TABLE IF EXISTS "</span> + FeedEntry.TABLE_NAME;</span><br></pre></td></tr></table></figure></p>
<p>就像是你保存在内部存储中的文件一样，Android将你的数据库存储在和应用关联的私有空间内。你的数据是安全的，因为默认这个区域不能被其他的app访问。</p>
<p>在 <a href="http://developer.android.com/reference/android/database/sqlite/SQLiteOpenHelper.html" target="_blank" rel="external">SQLiteOpenHelper</a> 类中能够找到很多有用的API。当你使用这个类来获得数据库的引用时，系统只会在需要的时候才会去做这种可能长时间的创建/更新数据酷的操作，而不会在app启动时这样做。你所需要做的只有调用 <a href="http://developer.android.com/reference/android/database/sqlite/SQLiteOpenHelper.html#getWritableDatabase(" target="_blank" rel="external">getWritableDatabase()</a>) 或者<a href="http://developer.android.com/reference/android/database/sqlite/SQLiteOpenHelper.html#getReadableDatabase(" target="_blank" rel="external">getReadableDatabase()</a>)。</p>
<p><strong>提示:</strong> 由于这可能会很长时间，确保要在后台线程中调用 <a href="http://developer.android.com/reference/android/database/sqlite/SQLiteOpenHelper.html#getWritableDatabase(" target="_blank" rel="external">getWritableDatabase()</a>) 或者<a href="http://developer.android.com/reference/android/database/sqlite/SQLiteOpenHelper.html#getReadableDatabase(" target="_blank" rel="external">getReadableDatabase()</a>) 方法，例如在 <a href="http://developer.android.com/reference/android/os/AsyncTask.html" target="_blank" rel="external">AsyncTask</a> 或者 <a href="http://developer.android.com/reference/android/app/IntentService.html" target="_blank" rel="external">IntentService</a>中。</p>
<p>在使用<a href="http://developer.android.com/reference/android/database/sqlite/SQLiteOpenHelper.html" target="_blank" rel="external">SQLiteOpenHelper</a>时，创建一个它的子类，实现 <a href="http://developer.android.com/reference/android/database/sqlite/SQLiteOpenHelper.html#onCreate(android.database.sqlite.SQLiteDatabase" target="_blank" rel="external">onCreate()</a>)， <a href="http://developer.android.com/reference/android/database/sqlite/SQLiteOpenHelper.html#onUpgrade(android.database.sqlite.SQLiteDatabase,%20int,%20int" target="_blank" rel="external">onUpgrade()</a>) 和<a href="http://developer.android.com/reference/android/database/sqlite/SQLiteOpenHelper.html#onOpen(android.database.sqlite.SQLiteDatabase" target="_blank" rel="external">onOpen()</a>) 回调方法。你可能还想实现<a href="http://developer.android.com/reference/android/database/sqlite/SQLiteOpenHelper.html#onDowngrade(android.database.sqlite.SQLiteDatabase,%20int,%20int" target="_blank" rel="external">onDowngrade()</a>)方法，但是它并不是必须的。</p>
<p>例如，下面展示了如何实现 <a href="http://developer.android.com/reference/android/database/sqlite/SQLiteOpenHelper.html" target="_blank" rel="external">SQLiteOpenHelper</a> 类，使用上面的一些命令：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span></span><br><span class="line"><span class="title">FeedReaderDbHelper</span> <span class="keyword">extends</span></span><br><span class="line"><span class="title">SQLiteOpenHelper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If you change the database schema, you must increment the database version.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> DATABASE_VERSION</span><br><span class="line">= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span></span><br><span class="line"><span class="keyword">final</span> String DATABASE_NAME</span><br><span class="line">=  <span class="string">"FeedReader.db "</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FeedReaderDbHelper</span><span class="params">(Context context)</span></span><br><span class="line"></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">super</span>(context, DATABASE_NAME,</span><br><span class="line"><span class="keyword">null</span>, DATABASE_VERSION);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(SQLiteDatabase db)</span></span><br><span class="line"></span>&#123;</span><br><span class="line"></span><br><span class="line">        db.execSQL(SQL_CREATE_ENTRIES);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onUpgrade</span><span class="params">(SQLiteDatabase db,</span><br><span class="line"><span class="keyword">int</span> oldVersion,</span><br><span class="line"><span class="keyword">int</span> newVersion)</span></span><br><span class="line"></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// This database is only a cache for online data, so its upgrade policy is</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// to simply to discard the data and start over</span></span><br><span class="line"></span><br><span class="line">        db.execSQL(SQL_DELETE_ENTRIES);</span><br><span class="line"></span><br><span class="line">        onCreate(db);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDowngrade</span><span class="params">(SQLiteDatabase db,</span><br><span class="line"><span class="keyword">int</span> oldVersion,</span><br><span class="line"><span class="keyword">int</span> newVersion)</span></span><br><span class="line"></span>&#123;</span><br><span class="line"></span><br><span class="line">        onUpgrade(db, oldVersion, newVersion);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>要访问你的数据库，实例化你所创建的<a href="http://developer.android.com/reference/android/database/sqlite/SQLiteOpenHelper.html" target="_blank" rel="external">SQLiteOpenHelper</a>的子类：</p>
<p>FeedReaderDbHelper mDbHelper =<br>new FeedReaderDbHelper(getContext());</p>
<p>向数据库中插入数据</p>
<p>通过将 <a href="http://developer.android.com/reference/android/content/ContentValues.html" target="_blank" rel="external">ContentValues</a> 对象传给<a href="http://developer.android.com/reference/android/database/sqlite/SQLiteDatabase.html#insert(java.lang.String,%20java.lang.String,%20android.content.ContentValues" target="_blank" rel="external">insert()</a>) 方法来向数据库中插入数据：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Gets the data repository in write mode</span></span><br><span class="line"></span><br><span class="line">SQLiteDatabase db = mDbHelper.getWritableDatabase();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a new map of values, where column names are the keys</span></span><br><span class="line"></span><br><span class="line">ContentValues values =</span><br><span class="line"><span class="keyword">new</span> ContentValues();</span><br><span class="line"></span><br><span class="line">values.put(FeedEntry.COLUMN_NAME_ENTRY_ID, id);</span><br><span class="line"></span><br><span class="line">values.put(FeedEntry.COLUMN_NAME_TITLE, title);</span><br><span class="line"></span><br><span class="line">values.put(FeedEntry.COLUMN_NAME_CONTENT, content);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Insert the new row, returning the primary key value of the new row</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> newRowId;</span><br><span class="line"></span><br><span class="line">newRowId = db.insert(</span><br><span class="line"></span><br><span class="line">         FeedEntry.TABLE_NAME,</span><br><span class="line"></span><br><span class="line">         FeedEntry.COLUMN_NAME_NULLABLE,</span><br><span class="line"></span><br><span class="line">         values);</span><br></pre></td></tr></table></figure></p>
<p><a href="http://developer.android.com/reference/android/database/sqlite/SQLiteDatabase.html#insert(java.lang.String,%20java.lang.String,%20android.content.ContentValues" target="_blank" rel="external">insert()</a>) 方法的第一个参数是“表名”。第二个参数将提供一些列名，当<a href="http://developer.android.com/reference/android/content/ContentValues.html" target="_blank" rel="external">ContentValues</a> 为空时，framework会给这些列插入NULL（如果你给这个参数传null，当没有&#20540;时，framework将不会插入）。</p>
<p>从数据库中读取数据</p>
<p>要从数据库中读取数据，使用 <a href="http://developer.android.com/reference/android/database/sqlite/SQLiteDatabase.html#query(boolean,%20java.lang.String,%20java.lang.String%5B%5D,%20java.lang.String,%20java.lang.String%5B%5D,%20java.lang.String,%20java.lang.String,%20java.lang.String,%20java.lang.String" target="_blank" rel="external">query()</a>) 方法，向它传入插叙条件以及需要返回的列。查询的结果将会通过Cursor对象返回：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">SQLiteDatabase db = mDbHelper.getReadableDatabase();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Define a _projection_ that specifies which columns from the database</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// you will actually use after this query.</span></span><br><span class="line"></span><br><span class="line">String[] projection</span><br><span class="line">= &#123;</span><br><span class="line"></span><br><span class="line">    FeedEntry._ID,</span><br><span class="line"></span><br><span class="line">    FeedEntry.COLUMN_NAME_TITLE,</span><br><span class="line"></span><br><span class="line">    FeedEntry.COLUMN_NAME_UPDATED,</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// How you want the results sorted in the resulting Cursor</span></span><br><span class="line"></span><br><span class="line">String sortOrder =</span><br><span class="line"></span><br><span class="line">    FeedEntry.COLUMN_NAME_UPDATED</span><br><span class="line"> ;  <span class="string">" DESC "</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Cursor c = db.query(</span><br><span class="line"></span><br><span class="line">    FeedEntry.TABLE_NAME,</span><br><span class="line"><span class="comment">// The table to query</span></span><br><span class="line"></span><br><span class="line">    projection,                              </span><br><span class="line"><span class="comment">// The columns to return</span></span><br><span class="line"></span><br><span class="line">    selection,                               </span><br><span class="line"><span class="comment">// The columns for the WHERE clause</span></span><br><span class="line"></span><br><span class="line">    selectionArgs,                           </span><br><span class="line"><span class="comment">// The values for the WHERE clause</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">null</span>,                                    </span><br><span class="line"><span class="comment">// don't group the rows</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">null</span>,                                    </span><br><span class="line"><span class="comment">// don't filter by row groups</span></span><br><span class="line"></span><br><span class="line">    sortOrder                                 <span class="comment">// The sort order</span></span><br><span class="line"></span><br><span class="line">    );</span><br></pre></td></tr></table></figure></p>
<p>要查看cursor中的数据，你每一次读取前都需要使用cursor的一个方法。一般来说，你需要在开始时调用 <a href="http://developer.android.com/reference/android/database/Cursor.html#moveToFirst(" target="_blank" rel="external">moveToFirst()</a>)方法，它会将游标指向 结果集中的第一项。Cursor中的每一行（row）数据你都可以调用Cursor中的一种get方法，例如 <a href="http://developer.android.com/reference/android/database/Cursor.html#getString(int" target="_blank" rel="external">getString()</a>) 或者 <a href="http://developer.android.com/reference/android/database/Cursor.html#getLong(int" target="_blank" rel="external">getLong()</a>)。每个get方法都需要传递一个当前列的索引，你可以通过调用 <a href="http://developer.android.com/reference/android/database/Cursor.html#getColumnIndex(java.lang.String" target="_blank" rel="external">getColumnIndex()</a>) 或者 <a href="http://developer.android.com/reference/android/database/Cursor.html#getColumnIndexOrThrow(java.lang.String" target="_blank" rel="external">getColumnIndexOrThrow()</a>)方法来获得索引。例如：</p>
<p>cursor.moveToFirst();</p>
<p>long itemId = cursor.getLong(</p>
<pre><code>cursor.getColumnIndexOrThrow(FeedEntry._ID)
</code></pre><p>);</p>
<p>删除数据库中的数据</p>
<p>要从表中删除一行数据，你需要提供能够定位到这一行的查询条件。数据库的API提供了一种能够阻止SQL注入的创建查询条件的机制。 这个机制将查询条件以及查询参数分离。（The mechanism divides the selection specification into a selection clause and selection arguments. The clause defines the columns to look at, and also allows you<br> to combine column tests. The arguments are values to test against that are bound into the clause.） 由于这种机制产生的结果不是常规的SQL语句，它有效地防止了SQL注入。</p>
<p>// Define ‘where’ part of query.</p>
<p>String selection =<br>FeedEntry.COLUMN_NAME_ENTRY_ID<br> ;  “ LIKE ? “;</p>
<p>// Specify arguments in placeholder order.</p>
<p>String[] selectionArgs<br>= {<br>String.valueOf(rowId)<br>};</p>
<p>// Issue SQL statement.</p>
<p>db.delete(table_name, selection, selectionArgs);</p>
<p>更新数据库</p>
<p>当你需要修改数据库中的数据时，使用 <a href="http://developer.android.com/reference/android/database/sqlite/SQLiteDatabase.html#update(java.lang.String,%20android.content.ContentValues,%20java.lang.String,%20java.lang.String%5B%5D" target="_blank" rel="external">update()</a>) 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">SQLiteDatabase db = mDbHelper.getReadableDatabase();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// New value for one column</span></span><br><span class="line"></span><br><span class="line">ContentValues values =</span><br><span class="line"><span class="keyword">new</span> ContentValues();</span><br><span class="line"></span><br><span class="line">values.put(FeedEntry.COLUMN_NAME_TITLE, title);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Which row to update, based on the ID</span></span><br><span class="line"></span><br><span class="line">String selection =</span><br><span class="line">FeedEntry.COLUMN_NAME_ENTRY_ID</span><br><span class="line"> ;  <span class="string">" LIKE ? "</span>;</span><br><span class="line"></span><br><span class="line">String[] selectionArgs</span><br><span class="line">= &#123;</span><br><span class="line">String.valueOf(rowId)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> count = db.update(</span><br><span class="line"></span><br><span class="line">    FeedReaderDbHelper.FeedEntry.TABLE_NAME,</span><br><span class="line"></span><br><span class="line">    values,</span><br><span class="line"></span><br><span class="line">    selection,</span><br><span class="line"></span><br><span class="line">    selectionArgs);</span><br></pre></td></tr></table></figure>
<pre><code>    作者：sweetvvck 发表于2014/9/30 23:55:32 [原文链接](http://blog.csdn.net/sweetvvck/article/details/38645119)


阅读：575 评论：0 [查看评论](http://blog.csdn.net/sweetvvck/article/details/38645119#comments)
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>对于可复用或者结构化的数据来说，把它们存储到数据库中是理想的方式。学习本课前你需要对通常的数据库有所了解，本课在此前提下会帮助你学习如何在android系统中操作SQLite数据库。你需要使用到的APIs都可以在<a href="http://developer.andro]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[[原]Android学习路线（二十五）全面理解Android Navigation逻辑]]></title>
    <link href="http://sweetvvck.github.io/2014/08/27/%E5%8E%9F-Android%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%EF%BC%88%E4%BA%8C%E5%8D%81%E4%BA%94%EF%BC%89%E5%85%A8%E9%9D%A2%E7%90%86%E8%A7%A3Android-Navigation%E9%80%BB%E8%BE%91/"/>
    <id>http://sweetvvck.github.io/2014/08/27/原-Android学习路线（二十五）全面理解Android-Navigation逻辑/</id>
    <published>2014-08-26T17:23:17.000Z</published>
    <updated>2016-01-25T20:07:04.000Z</updated>
    <content type="html"><![CDATA[<p>转载请注明出处：<a href="http://blog.csdn.net/sweetvvck/article/details/38832809" target="_blank" rel="external">Android学习路线（二十五）全面理解Android Navigation逻辑</a></p>
<p>应用导航的一致性是整体用户体验的重要组成部分，如果app的导航方式不一样，用户不能很快理解，那么这个应用会让用户有很大的挫败感，大大地影响了用户体验。</p>
<p>Android 3.0后，系统像大家介绍了其在全局导航表现上的重大改变。全面地理解“Back”以及“Up”的导航效果以及意义，能够大大地减少用户的学习时间，用户在使用过程中很快能够学习如何在应用的各个界面间的切换。</p>
<p>Android 2.3以及它之前的系统都是通过“Back”按钮来为app导航的。在Android 3.0后出现的Actionbar则带来了另一种一致性的导航方式：“Up”，它位于Actionbar的最左边，通常由应用的Icon以及Title组成。</p>
<p>下图分别展示了“Back”和“Up”的示例：</p>
<p><img src="http://img.blog.csdn.net/20140826002202399?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3dlZXR2dmNr/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<h1 id="Up_vs-_Back"><a href="#Up_vs-_Back" class="headerlink" title="Up vs. Back"></a>Up vs. Back</h1><hr>
<p>Up的导航逻辑是根据界面的层次结构决定的。例如A界面有一个列表，点击列表的Item进入B界面，这个时候，在B界面应该要提供一个Up按钮，点击Up则应该返回到A界面。</p>
<p>如果一个界面是app的主界面，则这个界面是不需要提供Up按钮的，而Back按钮在所有的界面都会起作用。</p>
<p>在应用中，Back的作用是返回到上一个界面中。如果把一个一个打开界面看成是入栈，那么点击Back按钮无疑代表着出栈，用户应该总是能够通过back操作找到上一个界面。</p>
<p>如果当前界面的上一个界面正好也是当前界面的父级界面，那么Back和Up的效果是同样的。但是，Up主要是在app内部使用，而Back则能够让用户回到手机的主界面，甚至能够回到其他的app中。</p>
<p>举个简单的例子：</p>
<p><img src="http://img.blog.csdn.net/20140826003932624?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3dlZXR2dmNr/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>在手机的主界面点击Gmail应用，进入到Gmail主界面中，主界面包含邮件的会话列表，点击其中一个会话会进入会话的详情界面。在会话详情页上，上一个界面和该界面的上级界面都是会话列表界面，因此点击Back和Up的效果是相同的，都会回到会话列表界面。可以发现，会话列表式Gmail的主界面，所以这个界面上是没有Up按钮的，这个时候则可以通过点击Back回到手机的主界面上。</p>
<p>Back除了能够处理这些界面间的切换，同时它还能处理一些统一界面上的导航逻辑，例如：</p>
<p>点击Back能够让当前界面的对话框消失，还能解除当前界面的文字高亮，同时它还能隐藏输入键盘等。</p>
<h2 id="u5355_u4E2A_u5E94_u7528_u5185_u90E8_u5BFC_u822A"><a href="#u5355_u4E2A_u5E94_u7528_u5185_u90E8_u5BFC_u822A" class="headerlink" title="单个应用内部导航"></a>单个应用内部导航</h2><p>当一个界面有很多入口时，在这个界面点击Up按钮应该回到进入到这个界面的相关界面，这样的效果和Back回到上一个界面的效果是相同的。例如设置界面，应用中可能有很多地方能够进入设置界面，此时点击Up和Back都会返回它的上一个界面。</p>
<p>如果在一个界面内切换视图，例如一个界面包含ViewPager，虽然左右滑动导致界面上的视图更改，但是此界面在app的界面层级并没有改变，同时也没有创建新的导航历史，因此这样的操作时不会引起Up和Back有新 的行为的。</p>
<p>例如：</p>
<p><img src="http://img.blog.csdn.net/20140826010627726?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3dlZXR2dmNr/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>在会话列表界面点击了其中一条会话，进入详情，在详情页左右滑动查看前后会话详情内容；但是此操作并没有切换界面（在app界面中的层级），因此这样并不能影响Back和Up的效果。</p>
<p>然而，如果在详情页点击了某个按钮进入了另一个详情界面，并且此时创建了导航历史。这样的话，点击Back会回到该详情页的上一个界面，而点击Up则会回到该界面在app中层级的上一级界面。</p>
<p>例如：</p>
<p><img src="http://img.blog.csdn.net/20140826011742859?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3dlZXR2dmNr/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>我们还可以让导航更加智能，比如我们在某个种类的列表界面点击Item进入详情页跳转到另一种类型的详情页，这时点击Back界面会转到上一个详情页，而点击Up则会返回到这种类型的列表页；如下图所示：</p>
<p><img src="http://img.blog.csdn.net/20140827003353545?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3dlZXR2dmNr/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>上过上面的讲解，我们可以大致了解Back和Up的不同作用与目的。用户进入到App，切换不同的界面，每个界面都会被加入到一个栈里，通常情况下Back的作用是返回到栈中的上一个界面；而Up与这个栈没有直接关系，除了应用主界面，其他界面都会有一个父级界面，Up的作用正是返回到当前界面的父级界面。</p>
<p>然而，有些情况为了让Back的效果有更好的可预测性，我们应到手动向Back的界面栈中添加界面，这样用户就能更清楚是如何进入到当前界面的。例如，当点击Android桌面上的Widgets进入到一个非app主界面中，如果没有向界面栈中手动插入app的主界面，点击返回就直接退到了手机Home界面，这样的体验不太好；因此我们会做手动向栈中插入界面的操作。详情如下图所示：</p>
<p><img src="http://img.blog.csdn.net/20140827004907843?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3dlZXR2dmNr/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<h2 id="u8DE8_u5E94_u7528_u5BFC_u822A"><a href="#u8DE8_u5E94_u7528_u5BFC_u822A" class="headerlink" title="跨应用导航"></a><strong>跨应用导航</strong></h2><p>在同一个App中Back和Up各司其职，有相同的地方也有不同的地方；而在夸应用的情况下，Back和Up有更多的不同之处。</p>
<p>要知道Back和Up跨App的导航效果，首先要知道下面三个概念：</p>
<p>Activities：我们都知道，一个Activity是一个展示信息界面与用户交互的应用组件，而一个app可以看成包含多个activities的集合；而这些activities可以是app自身定义的也可以是对其他app中activity的重用；</p>
<p>Task：Task表示用户一次完整操作的流程。例如用户打开某个应用，在应用的某个界面中点击分享内容，选择通过邮件方式分享；这样的一个过程称为task，可以看到这个过程是跨app的，这次task包含多个activities；</p>
<p>Intent：Intent表示界面跳转的意图，可以指定界面跳转，也可以根据界面支持的action跳转。例如系统中“Share”这个Intent，它会列出系统中所有支持分享的app；</p>
<p>了解了上面的概念后我们来看看这个例子：</p>
<p><img src="http://img.blog.csdn.net/20140827011051401?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3dlZXR2dmNr/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>用户在某个界面点击分享，跳转到Gmail中分享内容，这个过程是一个task，此时如果点击Back，则会返回到之前的app中；而如果点击Up，则会留在Gmail中，并且跳转到Gmail的主界面（当前界面的父级界面），这个过程是一个新的task。这个新的task会把老的task给覆盖掉，点击Back则返回系统Home界面。</p>
<p>纵观全文，我们了解到了系统推荐的导航准则。我们可以按照规范来，但是在我们的app中，我们也可以具体情况具体分析，总之一个原则就是让用户更快地学习使用app，让界面的导航有更好的可预测性。</p>
<p>本文大致解释了新版Android系统推荐的导航机制，想了解更加细致的内容请参考：<a href="http://developer.android.com/design/patterns/navigation.html" target="_blank" rel="external">Navigation with Back and Up</a>&nbsp;。本人也会在后续的文章中介绍ActionBar如何实现Up导航。</p>
<pre><code>    作者：sweetvvck 发表于2014/8/27 1:23:17 [原文链接](http://blog.csdn.net/sweetvvck/article/details/38832809)


阅读：2657 评论：10 [查看评论](http://blog.csdn.net/sweetvvck/article/details/38832809#comments)
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>转载请注明出处：<a href="http://blog.csdn.net/sweetvvck/article/details/38832809" target="_blank" rel="external">Android学习路线（二十五）全面理解Android Navi]]>
    </summary>
    
      <category term="Android" scheme="http://sweetvvck.github.io/tags/Android/"/>
    
      <category term="Native app" scheme="http://sweetvvck.github.io/categories/Native-app/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[原]Zookeeper集群搭建]]></title>
    <link href="http://sweetvvck.github.io/2014/08/26/%E5%8E%9F-Zookeeper%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"/>
    <id>http://sweetvvck.github.io/2014/08/26/原-Zookeeper集群搭建/</id>
    <published>2014-08-26T02:05:51.000Z</published>
    <updated>2016-01-25T19:48:44.000Z</updated>
    <content type="html"><![CDATA[<p>Zookeeper是Apache的一个开源项目，在集群管理中十分常用。它的集群搭建也十分简单，只需要简单的配置，集群的各个节点会完成自行通讯，自动选取Leader等。</p>
<p>更多关于zookeeper的信息和原理，可以参考这篇博文：<a href="http://blog.csdn.net/sweetvvck/article/details/38262965" target="_blank" rel="external">ZooKeeper原理及使用</a></p>
<p>Zookeeper的单机模式更加简单：</p>
<p>&nbsp; &nbsp; &nbsp; 在Ubuntu系统下，只需要执行sudo apt-get install zookeeper安装，然后到安装目录下找到zkServer.sh脚本，执行./zkServer.sh start就启动了zookeeper的单机模式，通过这种方式安装的zookeeper的目录通常是/usr/share/zookeeper/。通过执行zkServer.sh status可以看到zookeeper的运行状态，这里使用的是单机模式，则会显示：</p>
<p>JMX enabled by default<br>Using config: /etc/zookeeper/conf/zoo.cfg<br>Mode: standalone</p>
<p>&nbsp; &nbsp; &nbsp; 如果是在其他的Linux系统（CentOS）上，执行：</p>
<p>wget <a href="http://mirror.bit.edu.cn/apache/zookeeper/zookeeper-3.4.6/zookeeper-3.4.6.tar.gz" target="_blank" rel="external">http://mirror.bit.edu.cn/apache/zookeeper/zookeeper-3.4.6/zookeeper-3.4.6.tar.gz</a><br>tar zxf zookeeper-3.4.6.tar.gz<br>cd zookeeper-3.4.6/conf/</p>
<p>这个目录下有一个zoo_sample.cfg文件，是官方提供的示例配置，执行：</p>
<p>cp ./zoo_sample.cfg zoo.cfg</p>
<p>复制一份示例配置，改名为zoo.cfg，启动zookeeper：</p>
<p>../bin/zkServer.sh start</p>
<p>下面我们来尝试一下搭建zookeeper集群，由于机器有限，我采用在一台机器上搭建伪集群的方式来搭建集群。</p>
<p>zookeeper官方推荐集群的节点数要是奇数，因此我们这里准备搭建3个节点的集群。</p>
<p>首先，创建三个文件夹分别表示三个节点：</p>
<p>mkdir server0<br>mkdir server1<br>mkdir server2</p>
<p>然后将下载好的zookeeper文件解压到每个目录下：</p>
<p>tar xzvf zookeeper-3.4.6.tar.gz -C ./server0/<br>tar xzvf zookeeper-3.4.6.tar.gz -C ./server1/<br>tar xzvf zookeeper-3.4.6.tar.gz -C ./server2/</p>
<p>同时更改目录名称：</p>
<p>mv ./server0/zookeeper-3.4.6 ./server0/zookeeper<br>mv ./server1/zookeeper-3.4.6 ./server1/zookeeper<br>mv ./server2/zookeeper-3.4.6 ./server2/zookeeper</p>
<p>然后进入到每个节点的zookeeper目录下，分别创建data目录以及logs目录：</p>
<p>mkdir data<br>mkdir logs</p>
<p>然后在data目录下创建myid文件，内容为当前节点的序号，如0,1,2：</p>
<p>vim ./data/myid</p>
<p>填入序号，保存；</p>
<p>接下来进入conf目录创建zoo.cfg文件：</p>
<p>vim ./zoo.cfg</p>
<p>内容按下面方式填写：</p>
<p>tickTime=2000&nbsp;</p>
<p>initLimit=5&nbsp;</p>
<p>syncLimit=2&nbsp;</p>
<p>dataDir=/opt/server0/zookeeper/data&nbsp;</p>
<p>dataLogDir=/opt/server0/zookeeper/logs&nbsp;</p>
<p>clientPort=2180</p>
<p>server.0=127.0.0.1:8880:7770&nbsp;</p>
<p>server.1=127.0.0.1:8881:7771&nbsp;</p>
<p>server.2=127.0.0.1:8882:7772</p>
<p>其中标红的部分要根据当前节点序号进行修改，例如当前在server0目录下，则按照上面的配置填写，然后保存。</p>
<p>填写完配置后就可以启动zookeeper了：</p>
<p>./bin/zkServer.sh start</p>
<p>然后在另外两个节点的目录下重复上述操作，伪集群就搭建好啦。</p>
<p>通过./bin/zkServer.sh status可以看到当前节点在集群中的角色，显示如下：</p>
<p>JMX enabled by default<br>Using config: /opt/zookeeper/server0/zookeeper/bin/../conf/zoo.cfg<br>Mode: follower</p>
<p>通过./bin/zkCli.sh -server host:port的方式能够指定任一一个节点访问到集群：</p>
<p>./bin/zkCli.sh -server 127.0.0.1:2181</p>
<pre><code>    作者：sweetvvck 发表于2014/8/26 10:05:51 [原文链接](http://blog.csdn.net/sweetvvck/article/details/38842665)


阅读：1153 评论：0 [查看评论](http://blog.csdn.net/sweetvvck/article/details/38842665#comments)
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>Zookeeper是Apache的一个开源项目，在集群管理中十分常用。它的集群搭建也十分简单，只需要简单的配置，集群的各个节点会完成自行通讯，自动选取Leader等。</p>
<p>更多关于zookeeper的信息和原理，可以参考这篇博文：<a href="http://b]]>
    </summary>
    
      <category term="zookeeper" scheme="http://sweetvvck.github.io/tags/zookeeper/"/>
    
      <category term="运维" scheme="http://sweetvvck.github.io/categories/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="架构" scheme="http://sweetvvck.github.io/categories/%E8%BF%90%E7%BB%B4/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[原]Android学习路线（二十四）ActionBar Fragment运用最佳实践]]></title>
    <link href="http://sweetvvck.github.io/2014/08/21/%E5%8E%9F-Android%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%EF%BC%88%E4%BA%8C%E5%8D%81%E5%9B%9B%EF%BC%89ActionBar-Fragment%E8%BF%90%E7%94%A8%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    <id>http://sweetvvck.github.io/2014/08/21/原-Android学习路线（二十四）ActionBar-Fragment运用最佳实践/</id>
    <published>2014-08-20T19:03:52.000Z</published>
    <updated>2016-01-25T19:47:24.000Z</updated>
    <content type="html"><![CDATA[<p>转载请注明出处：<a href="http://blog.csdn.net/sweetvvck/article/details/38645297" target="_blank" rel="external">http://blog.csdn.net/sweetvvck/article/details/38645297</a></p>
<p>通过前面的几篇博客，大家看到了Google是如何解释action bar和fragment以及推荐的用法。俗话说没有demo的博客不是好博客，下面我会介绍一下action bar和fragment在实战中的应用，以及相关demo源码，希望和大家相互交流。</p>
<p>了解过fragment的同学们应该都知道，fragment是android 3.0版本才出现的的，因此如果要在支持android 3.0一下版本的工程中使用fragment的话是需要添加Support Library的。具体如何添加我就不再赘述，可以看我前面的博客<a href="http://blog.csdn.net/sweetvvck/article/details/38566871" target="_blank" rel="external">Android学习路线（二十一）运用Fragment构建动态UI——创建一个Fragment</a>，下面的项目支持到API<br> Level最低为8，所以项目中也会使用到Support Library。</p>
<p>作为一个有上进心的Android开发者，我们是希望项目的设计符合<strong>Android Design</strong>的。Android Design是Google官方推荐的应用设计原则，不了解Android Design的同学可以去了解下，我这里有<a href="http://download.csdn.net/detail/sweetvvck/7835793" target="_blank" rel="external">官方翻译文档</a>。</p>
<p>我发现“知乎”的App设计是符合Android Design的，那么我们的项目就来模仿知乎的主界面。首先看下效果图：</p>
<p><img src="http://img.blog.csdn.net/20140818082016785?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3dlZXR2dmNr/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="">&nbsp;<br> &nbsp; &nbsp; &nbsp;<img src="http://img.blog.csdn.net/20140818082105582?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3dlZXR2dmNr/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>我们来分析一下这样的界面应该怎么实现，从上图可以看出“知乎”android端使用了action bar和drawerlayout，同时drawer中item切换主界面应该是fragment。</p>
<p>新建一个工程FakeZhihu：</p>
<p><img src="http://img.blog.csdn.net/20140818083926546?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3dlZXR2dmNr/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="">&nbsp;&nbsp;<img src="http://img.blog.csdn.net/20140821010348778?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3dlZXR2dmNr/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>&nbsp; &nbsp; &nbsp; 从上图可以看到，使用最新的adt插件创建android项目时，如果选择的Minimum Required SDK为8，而Target SDK大于它的话，系统会自动在项目中导入Support v4包；在创建项目向导最后一步可以选择Navigation Type，如果选择了Navigation Drawer，adt工具会在创建项目时自动生成DrawerLayout相关示例代码。但由于DrawerLayout是在高版本的API中出现的，因此adt工具会帮助导入Support<br> v7 appcompat包，这样DrawerLayout就可以兼容到Android2.2了。没有使用最新版的adt工具也没有关系，我提供的demo里有Support v4包和Support v7包，大家可以直接使用。</p>
<p>&nbsp; &nbsp; &nbsp; 下面来看看代码如何实现，android默认的holo主题只提供两种色调，和官方的action bar比较可以看出“知乎”的action bar的颜色以及action bar上action item的颜色以及title的字体大小都是自定义的，那么我们来模仿它自定义一下action bar。</p>
<p>&nbsp; &nbsp; &nbsp; 首先我们打开res目录下的style文件，自定义一个主题和action bar的style，然后在自定义主题中引用自定义的action bar的style：</p>
<p>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;<br>&lt;resources&gt;<br>    &lt;!– the theme applied to the application or activity –&gt;<br>    &lt;style name=&quot;CustomActionBarTheme&quot;<br>           parent=&quot;@style/Theme.AppCompat.Light.DarkActionBar&quot;&gt;<br>        &lt;item name=&quot;android:actionBarStyle&quot;&gt;@style/MyActionBar&lt;/item&gt;</p>
<pre><code>    &amp;lt;!-- Support library compatibility --&amp;gt;
    &amp;lt;item name=&amp;quot;actionBarStyle&amp;quot;&amp;gt;@style/MyActionBar&amp;lt;/item&amp;gt;
&amp;lt;/style&amp;gt;

&amp;lt;!-- ActionBar styles --&amp;gt;
&amp;lt;style name=&amp;quot;MyActionBar&amp;quot;
       parent=&amp;quot;@style/Widget.AppCompat.Light.ActionBar.Solid.Inverse&amp;quot;&amp;gt;
    &amp;lt;item name=&amp;quot;android:background&amp;quot;&amp;gt;@drawable/actionbar_background&amp;lt;/item&amp;gt;
    &amp;lt;item name=&amp;quot;android:titleTextStyle&amp;quot;&amp;gt;@style/MyTitleStyle&amp;lt;/item&amp;gt;

    &amp;lt;!-- Support library compatibility --&amp;gt;
    &amp;lt;item name=&amp;quot;background&amp;quot;&amp;gt;@drawable/actionbar_background&amp;lt;/item&amp;gt;
    &amp;lt;item name=&amp;quot;titleTextStyle&amp;quot;&amp;gt;@style/MyTitleStyle&amp;lt;/item&amp;gt;
&amp;lt;/style&amp;gt;
&amp;lt;style name=&amp;quot;MyTitleStyle&amp;quot;
       parent=&amp;quot;@android:style/TextAppearance.Holo.Widget.ActionBar.Title.Inverse&amp;quot;&amp;gt;
    &amp;lt;item name=&amp;quot;android:textSize&amp;quot;&amp;gt;20dp&amp;lt;/item&amp;gt;
&amp;lt;/style&amp;gt;
</code></pre><p>&lt;/resources&gt;这里要注意的是<strong>无论是在自定义主题还是自定义style时，要根据情况加上parent属性，如果没有加上相应的parent属性的话就不能使用父style中没有被覆盖的样式</strong>。具体如何设置action bar的style可以参考<a href="http://blog.csdn.net/sweetvvck/article/details/38409785" target="_blank" rel="external"><br> Android学习路线（九）为Action Bar添加Style</a>。</p>
<p>完成自定义主题和style后要记得在manifest文件中应用：</p>
<p>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;<br>&lt;manifest xmlns:android=&quot;<a href="http://schemas.android.com/apk/res/android&amp;quot" target="_blank" rel="external">http://schemas.android.com/apk/res/android&amp;quot</a>;<br>    package=&quot;com.sweetvvck.fakezhihu&quot;<br>    android:versionCode=&quot;1&quot;<br>    android:versionName=&quot;1.0&quot; &gt;</p>
<pre><code>&amp;lt;uses-sdk
    android:minSdkVersion=&amp;quot;8&amp;quot;
    android:targetSdkVersion=&amp;quot;19&amp;quot; /&amp;gt;

&amp;lt;application
    android:allowBackup=&amp;quot;true&amp;quot;
    android:icon=&amp;quot;@drawable/ic_launcher&amp;quot;
    android:label=&amp;quot;@string/app_name&amp;quot;
    android:theme=&amp;quot;@style/CustomActionBarTheme&amp;quot; &amp;gt;
    &amp;lt;activity
        android:name=&amp;quot;com.sweetvvck.fakezhihu.MainActivity&amp;quot;
        android:label=&amp;quot;@string/app_name&amp;quot; &amp;gt;
        &amp;lt;intent-filter&amp;gt;
            &amp;lt;action android:name=&amp;quot;android.intent.action.MAIN&amp;quot; /&amp;gt;

            &amp;lt;category android:name=&amp;quot;android.intent.category.LAUNCHER&amp;quot; /&amp;gt;
        &amp;lt;/intent-filter&amp;gt;
    &amp;lt;/activity&amp;gt;
&amp;lt;/application&amp;gt;
</code></pre><p>&lt;/manifest&gt;<br>这里可以让整个应用都使用自定义的主题，也可以指定单个activity使用，使用android:theme属性来指定。</p>
<p>接下来要给app添加DrawerLayout了，修改MainActivity的布局文件，添加一个DrawerLayout，内容非常简单，其中包含一个Drawer和内容布局的Container：</p>
<p>&lt;android.support.v4.widget.DrawerLayout xmlns:android=&quot;<a href="http://schemas.android.com/apk/res/android&amp;quot" target="_blank" rel="external">http://schemas.android.com/apk/res/android&amp;quot</a>;<br>    xmlns:tools=&quot;<a href="http://schemas.android.com/tools&amp;quot" target="_blank" rel="external">http://schemas.android.com/tools&amp;quot</a>;<br>    android:id=&quot;@+id/drawer_layout&quot;<br>    android:layout_width=&quot;match_parent&quot;<br>    android:layout_height=&quot;match_parent&quot;<br>    tools:context=&quot;com.sweetvvck.fakezhihu.MainActivity&quot; &gt;</p>
<pre><code>&amp;lt;FrameLayout
    android:id=&amp;quot;@+id/container&amp;quot;
    android:layout_width=&amp;quot;match_parent&amp;quot;
    android:layout_height=&amp;quot;match_parent&amp;quot; /&amp;gt;

&amp;lt;fragment
    android:id=&amp;quot;@+id/navigation_drawer&amp;quot;
    android:name=&amp;quot;com.sweetvvck.fakezhihu.NavigationDrawerFragment&amp;quot;
    android:layout_width=&amp;quot;@dimen/navigation_drawer_width&amp;quot;
    android:layout_height=&amp;quot;match_parent&amp;quot;
    android:layout_gravity=&amp;quot;start&amp;quot; /&amp;gt;
</code></pre><p>&lt;/android.support.v4.widget.DrawerLayout&gt;<br>注意，下面那个fragment就是app的Drawer，<strong>其中的属性android:layout_gravity在这里表示Drawer从哪一侧划出，start代表左侧，end代表右侧；还可以定义两个fragment，然后一个左侧划出一个右侧划出</strong>，DrawerLayout在之后会详细讲解，这里先简单了解如何使用。</p>
<p>创建完DrawerLayout布局后，我们来为Drawer定义一个fragment，我们可以看到知乎的Drawer中只是包含了一个ListView。这个ListView的第一项和其它项的布局不一样，我们可以想到用ListView加上headerView来实现，知道这些后，我们来创建一个NavigationDrawerFragment继承自Fragment，这个fragment的布局包含一个ListView：</p>
<p>&lt;ListView xmlns:android=&quot;<a href="http://schemas.android.com/apk/res/android&amp;quot" target="_blank" rel="external">http://schemas.android.com/apk/res/android&amp;quot</a>;<br>    xmlns:tools=&quot;<a href="http://schemas.android.com/tools&amp;quot" target="_blank" rel="external">http://schemas.android.com/tools&amp;quot</a>;<br>    android:layout_width=&quot;match_parent&quot;<br>    android:layout_height=&quot;match_parent&quot;<br>    android:background=&quot;#fff&quot;<br>    android:choiceMode=&quot;singleChoice&quot;<br>    android:divider=&quot;#c3c3c3&quot;<br>    android:dividerHeight=&quot;0.5dp&quot;<br>    tools:context=&quot;com.sweetvvck.fakezhihu.NavigationDrawerFragment&quot; /&gt;<br>使用一个ArrayList来存放ListView的数据，定义一个DrawerListItem对象来存放每个Item的title和icon的资源ID：</p>
<p>&lt;string-array name=&quot;item_title&quot;&gt;<br>    &lt;item&gt;首页&lt;/item&gt;<br>    &lt;item&gt;发现&lt;/item&gt;<br>    &lt;item&gt;关注&lt;/item&gt;<br>    &lt;item&gt;收藏&lt;/item&gt;<br>    &lt;item&gt;草稿&lt;/item&gt;<br>    &lt;item&gt;搜索&lt;/item&gt;<br>    &lt;item&gt;提问&lt;/item&gt;<br>    &lt;item&gt;设置&lt;/item&gt;<br>&lt;/string-array&gt;String[] itemTitle = getResources().getStringArray(R.array.item_title);<br>int[] itemIconRes = {<br>  R.drawable.ic_drawer_home,<br>  R.drawable.ic_drawer_explore,<br>  R.drawable.ic_drawer_follow,<br>  R.drawable.ic_drawer_collect,<br>  R.drawable.ic_drawer_draft,<br>  R.drawable.ic_drawer_search,<br>  R.drawable.ic_drawer_question,<br>  R.drawable.ic_drawer_setting};</p>
<p>for (int i = 0; i &lt; itemTitle.length; i++) {<br>    DrawerListItem item = new DrawerListItem(getResources().getDrawable(itemIconRes[i]), itemTitle[i]);<br>    mData.add(item);</p>
<p>}准备好数据后为该ListView设置Adapter，我们发现这个ListView是Single Choice模式的，并且每个Item被选中后会高亮。那么如何来实现这个功能呢？</p>
<p>实现这样的效果有两个步骤：</p>
<p>&nbsp; &nbsp; &nbsp; 第一：在ListView中指定android:choiceMode=&quot;singleChoice&quot;；</p>
<p>&nbsp; &nbsp; &nbsp; 第二：给ListView的Item的布局设置一个特殊的背景drawable，这个drawable包含当状态为activated时的背景和常态下的背景；同时这个item布局中的图片src和文字颜色也要坐相应的设置；</p>
<p>item的背景：</p>
<p>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;<br>&lt;selector xmlns:android=&quot;<a href="http://schemas.android.com/apk/res/android&quot;&amp;gt" target="_blank" rel="external">http://schemas.android.com/apk/res/android&quot;&amp;gt</a>;<br>    &lt;item android:state_activated=&quot;true&quot; android:drawable=&quot;@drawable/activated_background_color&quot; /&gt;<br>    &lt;item android:drawable=&quot;@android:color/transparent&quot; /&gt;<br>&lt;/selector&gt;图片的src，这里以home为例：</p>
<p>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;<br>&lt;selector xmlns:android=&quot;<a href="http://schemas.android.com/apk/res/android&quot;&amp;gt" target="_blank" rel="external">http://schemas.android.com/apk/res/android&quot;&amp;gt</a>;<br>    &lt;item android:state_activated=&quot;true&quot; android:drawable=&quot;@drawable/ic_drawer_home_pressed&quot; /&gt;<br>    &lt;item android:drawable=&quot;@drawable/ic_drawer_home_normal&quot; /&gt;<br>&lt;/selector&gt;文字的颜色：</p>
<p>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;<br>&lt;!– Copyright (C) 2011 Google Inc. All Rights Reserved. –&gt;<br>&lt;selector xmlns:android=&quot;<a href="http://schemas.android.com/apk/res/android&quot;&amp;gt" target="_blank" rel="external">http://schemas.android.com/apk/res/android&quot;&amp;gt</a>;<br>    &lt;item android:state_enabled=&quot;false&quot;<br>        android:color=&quot;#ff999999&quot;/&gt;<br>    &lt;item android:state_activated=&quot;true&quot;<br>        android:color=&quot;@android:color/white&quot; /&gt;<br>    &lt;item<br>        android:color=&quot;#636363&quot; /&gt;<br>&lt;/selector&gt;<br>这样就能实现ListView点击Item高亮的效果了。</p>
<p>考虑到用户在第一次使用app的时候可能不知道有Drawer的存在，我们可以在app第一次被启动时让Drawer处于打开状态，之后再默认隐藏，<strong>这是实际项目中常用的手段</strong>，这里我们用sharedpreference来实现：</p>
<p>// 通过这个flag判断用户是否已经知道drawer了，第一次启动应用显示出drawer（抽屉），之后启动应用默认将其SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(getActivity());<br>mUserLearnedDrawer = sp.getBoolean(PREF_USER_LEARNED_DRAWER, false);接下来，要实现Drawer的fragment和宿主activity之间的通讯，需要定义一个回调接口，并且在宿主activity中实现：</p>
<p>/**</p>
<ul>
<li>宿主activity要实现的回调接口<em> 用于activity与该fragment之间通讯
</em>/<br>public static interface NavigationDrawerCallbacks {<br>  /**<ul>
<li>当drawer中的某个item被选择是调用该方法<br>*/<br>void onNavigationDrawerItemSelected(String title);<br>}@Override<br>public void onNavigationDrawerItemSelected(String title) {<br>FragmentManager fragmentManager = getSupportFragmentManager();<br>FragmentTransaction ft = fragmentManager.beginTransaction();<br>currentFragment = fragmentManager.findFragmentByTag(title);<br>if(currentFragment == null) {<br> currentFragment = ContentFragment.newInstance(title);<br> ft.add(R.id.container, currentFragment, title);<br>}<br>if(lastFragment != null) {<br> ft.hide(lastFragment);<br>}<br>if(currentFragment.isDetached()){<br> ft.attach(currentFragment);<br>}<br>ft.show(currentFragment);<br>lastFragment = currentFragment;<br>ft.commit();<br>onSectionAttached(title);<br>}具体如何来创建一个fragment以及如何实现fragment和activity之间的通讯，可以参考：<a href="http://blog.csdn.net/sweetvvck/article/details/38566871" target="_blank" rel="external">Android学习路线（二十一）运用Fragment构建动态UI——创建一个Fragment</a>&nbsp;和&nbsp;<a href="http://blog.csdn.net/sweetvvck/article/details/38569351" target="_blank" rel="external">Android学习路线（二十三）运用Fragment构建动态UI——Fragment间通讯</a>&nbsp;；完整的NavigationDrawerFragment代码如下：</li>
</ul>
</li>
</ul>
<p>package com.sweetvvck.fakezhihu;</p>
<p>import java.util.ArrayList;<br>import java.util.List;</p>
<p>import android.app.Activity;<br>import android.content.SharedPreferences;<br>import android.content.res.Configuration;<br>import android.os.Bundle;<br>import android.preference.PreferenceManager;<br>import android.support.v4.app.ActionBarDrawerToggle;<br>import android.support.v4.app.Fragment;<br>import android.support.v4.view.GravityCompat;<br>import android.support.v4.widget.DrawerLayout;<br>import android.support.v7.app.ActionBar;<br>import android.support.v7.app.ActionBarActivity;<br>import android.view.LayoutInflater;<br>import android.view.Menu;<br>import android.view.MenuInflater;<br>import android.view.MenuItem;<br>import android.view.View;<br>import android.view.ViewGroup;<br>import android.widget.AdapterView;<br>import android.widget.ListView;<br>import android.widget.Toast;</p>
<p>/**</p>
<ul>
<li>用于管理交互和展示抽屉导航的Fragment。</li>
<li>参考&lt;a href=&quot;<a href="https://developer.android.com/design/patterns/navigation-drawer.html#Interaction&quot;&amp;gt" target="_blank" rel="external">https://developer.android.com/design/patterns/navigation-drawer.html#Interaction&quot;&amp;gt</a>;</li>
<li><p>设计向导&lt;/a&gt;<br>*/<br>public class NavigationDrawerFragment extends Fragment {</p>
<p> /**</p>
<ul>
<li><p>存放选中item的位置<br>*/<br>private static final String STATE_SELECTED_POSITION = &quot;selected_navigation_drawer_position&quot;;</p>
<p>/**</p>
</li>
<li><p>存放用户是否需要默认开启drawer的key<br>*/<br>private static final String PREF_USER_LEARNED_DRAWER = &quot;navigation_drawer_learned&quot;;</p>
<p>/**</p>
</li>
<li><p>宿主activity实现的回调接口的引用<br>*/<br>private NavigationDrawerCallbacks mCallbacks;</p>
<p>/**</p>
</li>
<li><p>将action bar和drawerlayout绑定的组件<br>*/<br>private ActionBarDrawerToggle mDrawerToggle;</p>
<p>private DrawerLayout mDrawerLayout;<br>private ListView mDrawerListView;<br>private View mFragmentContainerView;</p>
<p>private int mCurrentSelectedPosition = 0;<br>private boolean mFromSavedInstanceState;<br>private boolean mUserLearnedDrawer;<br>private List&lt;DrawerListItem&gt; mData = new ArrayList&lt;DrawerListItem&gt;();</p>
<p>public NavigationDrawerFragment() {<br>}</p>
<p>@Override<br>public void onCreate(Bundle savedInstanceState) {<br> super.onCreate(savedInstanceState);</p>
<p> // 通过这个flag判断用户是否已经知道drawer了，第一次启动应用显示出drawer（抽屉），之后启动应用默认将其隐藏<br> SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(getActivity());<br> mUserLearnedDrawer = sp.getBoolean(PREF_USER_LEARNED_DRAWER, false);</p>
<p> if (savedInstanceState != null) {</p>
<pre><code>mCurrentSelectedPosition = savedInstanceState.getInt(STATE_SELECTED_POSITION);
mFromSavedInstanceState = true;
</code></pre><p> }</p>
<p>}</p>
<p>@Override<br>public void onActivityCreated (Bundle savedInstanceState) {<br> super.onActivityCreated(savedInstanceState);<br> // 设置该fragment拥有自己的actionbar action item<br> setHasOptionsMenu(true);<br>}</p>
<p>@Override<br>public View onCreateView(LayoutInflater inflater, ViewGroup container,</p>
<pre><code>Bundle savedInstanceState) {
</code></pre><p> mDrawerListView = (ListView) inflater.inflate(R.layout.fragment_navigation_drawer, container, false);<br> View headerView = inflater.inflate(R.layout.list_header, null);<br> mDrawerListView.addHeaderView(headerView);<br> mDrawerListView.setOnItemClickListener(new AdapterView.OnItemClickListener() {</p>
<pre><code>@Override
public void onItemClick(AdapterView&amp;lt;?&amp;gt; parent, View view, int position, long id) {
    selectItem(position);
}
</code></pre><p> });<br> String[] itemTitle = getResources().getStringArray(R.array.item_title);<br> int[] itemIconRes = {</p>
<pre><code>R.drawable.ic_drawer_home,
R.drawable.ic_drawer_explore,
R.drawable.ic_drawer_follow,
R.drawable.ic_drawer_collect,
R.drawable.ic_drawer_draft,
R.drawable.ic_drawer_search,
R.drawable.ic_drawer_question,
R.drawable.ic_drawer_setting};
</code></pre><p> for (int i = 0; i &lt; itemTitle.length; i++) {</p>
<pre><code>DrawerListItem item = new DrawerListItem(getResources().getDrawable(itemIconRes[i]), itemTitle[i]);
mData.add(item);
</code></pre><p> }<br> selectItem(mCurrentSelectedPosition);<br> DrawerListAdapter adapter = new DrawerListAdapter(this.getActivity(), mData);<br> mDrawerListView.setAdapter(adapter);<br> mDrawerListView.setItemChecked(mCurrentSelectedPosition, true);<br> return mDrawerListView;<br>}</p>
<p>public boolean isDrawerOpen() {<br> return mDrawerLayout != null &amp;&amp; mDrawerLayout.isDrawerOpen(mFragmentContainerView);<br>}</p>
<p>/**</p>
</li>
<li>设置导航drawer<br>*</li>
<li>@param fragmentId   fragmentent的id</li>
<li><p>@param drawerLayout fragment的容器<br>*/<br>public void setUp(int fragmentId, DrawerLayout drawerLayout) {<br> mFragmentContainerView = getActivity().findViewById(fragmentId);<br> mDrawerLayout = drawerLayout;</p>
<p> mDrawerLayout.setDrawerShadow(R.drawable.drawer_shadow, GravityCompat.START);</p>
<p> ActionBar actionBar = getActionBar();<br> actionBar.setDisplayHomeAsUpEnabled(true);<br> actionBar.setHomeButtonEnabled(true);<br> //隐藏Action bar上的app icon<br> actionBar.setDisplayShowHomeEnabled(false);</p>
<p> mDrawerToggle = new ActionBarDrawerToggle(</p>
<pre><code>getActivity(),                    /* 宿主 */
mDrawerLayout,                    /* DrawerLayout 对象 */
R.drawable.ic_drawer,             /* 替换actionbar上的&amp;#39;Up&amp;#39;图标 */
R.string.navigation_drawer_open,  
R.string.navigation_drawer_close
</code></pre><p> ) {</p>
<pre><code>@Override
public void onDrawerClosed(View drawerView) {
    super.onDrawerClosed(drawerView);
    if (!isAdded()) {
        return;
    }

    getActivity().supportInvalidateOptionsMenu(); // 调用 onPrepareOptionsMenu()
}

@Override
public void onDrawerOpened(View drawerView) {
    super.onDrawerOpened(drawerView);
    if (!isAdded()) {
        return;
    }

    if (!mUserLearnedDrawer) {
        mUserLearnedDrawer = true;
        SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(getActivity());
        sp.edit().putBoolean(PREF_USER_LEARNED_DRAWER, true).commit();
    }

    getActivity().supportInvalidateOptionsMenu(); // 调用 onPrepareOptionsMenu()
}
</code></pre><p> };</p>
<p> // 如果是第一次进入应用，显示抽屉<br> if (!mUserLearnedDrawer &amp;&amp; !mFromSavedInstanceState) {</p>
<pre><code>mDrawerLayout.openDrawer(mFragmentContainerView);
</code></pre><p> }</p>
<p> mDrawerLayout.post(new Runnable() {</p>
<pre><code>@Override
public void run() {
    mDrawerToggle.syncState();
}
</code></pre><p> });</p>
<p> mDrawerLayout.setDrawerListener(mDrawerToggle);<br>}</p>
<p>private void selectItem(int position) {<br> mCurrentSelectedPosition = position;<br> if (mDrawerListView != null) {</p>
<pre><code>mDrawerListView.setItemChecked(position, true);
</code></pre><p> }<br> if (mDrawerLayout != null) {</p>
<pre><code>mDrawerLayout.closeDrawer(mFragmentContainerView);
</code></pre><p> }<br> if (mCallbacks != null) {</p>
<pre><code>if(mCurrentSelectedPosition == 0) {
    mCallbacks.onNavigationDrawerItemSelected(getString(R.string.app_name));
    return;
}
mCallbacks.onNavigationDrawerItemSelected(mData.get(position - 1).getTitle());
</code></pre><p> }<br>}</p>
<p>@Override<br>public void onAttach(Activity activity) {<br> super.onAttach(activity);<br> try {</p>
<pre><code>mCallbacks = (NavigationDrawerCallbacks) activity;
</code></pre><p> } catch (ClassCastException e) {</p>
<pre><code>throw new ClassCastException(&amp;quot;Activity must implement NavigationDrawerCallbacks.&amp;quot;);
</code></pre><p> }<br>}</p>
<p>@Override<br>public void onDetach() {<br> super.onDetach();<br> mCallbacks = null;<br>}</p>
<p>@Override<br>public void onSaveInstanceState(Bundle outState) {<br> super.onSaveInstanceState(outState);<br> outState.putInt(STATE_SELECTED_POSITION, mCurrentSelectedPosition);<br>}</p>
<p>@Override<br>public void onConfigurationChanged(Configuration newConfig) {<br> super.onConfigurationChanged(newConfig);<br> // 当系统配置改变时调用DrawerToggle的改变配置方法（例如横竖屏切换会回调此方法）<br> mDrawerToggle.onConfigurationChanged(newConfig);<br>}</p>
<p>@Override<br>public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {<br> //当抽屉打开时显示应用全局的actionbar设置<br> if (mDrawerLayout != null &amp;&amp; isDrawerOpen()) {</p>
<pre><code>inflater.inflate(R.menu.global, menu);
showGlobalContextActionBar();
</code></pre><p> }<br> super.onCreateOptionsMenu(menu, inflater);<br>}</p>
<p>@Override<br>public boolean onOptionsItemSelected(MenuItem item) {<br> if (mDrawerToggle.onOptionsItemSelected(item)) {</p>
<pre><code>return true;
</code></pre><p> }</p>
<p> if (item.getItemId() == R.id.action_example) {</p>
<pre><code>Toast.makeText(getActivity(), &amp;quot;Example action.&amp;quot;, Toast.LENGTH_SHORT).show();
return true;
</code></pre><p> }</p>
<p> return super.onOptionsItemSelected(item);<br>}</p>
<p>/**</p>
</li>
<li><p>当抽屉打开时显示应用全局的actionbar设置<br>*/<br>private void showGlobalContextActionBar() {<br> ActionBar actionBar = getActionBar();<br> actionBar.setDisplayShowTitleEnabled(true);<br> actionBar.setNavigationMode(ActionBar.NAVIGATION_MODE_STANDARD);<br> actionBar.setTitle(R.string.app_name);<br>}</p>
<p>private ActionBar getActionBar() {<br> return ((ActionBarActivity) getActivity()).getSupportActionBar();<br>}</p>
<p>/**</p>
</li>
<li>宿主activity要实现的回调接口</li>
<li>用于activity与该fragment之间通讯<br><em>/<br>public static interface NavigationDrawerCallbacks {<br> /*</em><ul>
<li>当drawer中的某个item被选择是调用该方法<br>*/<br>void onNavigationDrawerItemSelected(String title);<br>}</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>}</p>
<p>这样就完成模仿“知乎”主界面的demo的开发啦，来看看效果如何：</p>
<p><img src="http://img.blog.csdn.net/20140821024716201?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3dlZXR2dmNr/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="">&nbsp;&nbsp;<img src="http://img.blog.csdn.net/20140821024753703?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3dlZXR2dmNr/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="">&nbsp;&nbsp;<img src="http://img.blog.csdn.net/20140821024813359?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3dlZXR2dmNr/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>怎么样，很像吧，Drawer是不是简直可以以假乱真了，哈哈。</p>
<p>demo地址：<a href="http://download.csdn.net/detail/sweetvvck/7794083" target="_blank" rel="external">http://download.csdn.net/detail/sweetvvck/7794083</a></p>
<p>其实demo中还有写知识点没有讲到，比如drawer划开时和关闭时action bar上的action item其实是不一样的，这时如何实现的呢？怎么设置action bar不现实logo/icon？选择Drawer中listview的item切换fragment可以每选择一次都replace一次fragment，但是这样每次都得重新创建一个fragment，如果fragment初始化较复杂就更占资源，此时可以配合使用add，hide，show来实现切换同时将以加载过的fragment缓存起来……由于篇幅原因，这些问题都会在之后的博客中详细讲到的~</p>
<p>&#65279;&#65279;</p>
<pre><code>    作者：sweetvvck 发表于2014/8/21 3:03:52 [原文链接](http://blog.csdn.net/sweetvvck/article/details/38645297)


阅读：6955 评论：20 [查看评论](http://blog.csdn.net/sweetvvck/article/details/38645297#comments)
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>转载请注明出处：<a href="http://blog.csdn.net/sweetvvck/article/details/38645297" target="_blank" rel="external">http://blog.csdn.net/sweetvvck/a]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[[译]Android学习路线（二十三）运用Fragment构建动态UI——Fragment间通讯]]></title>
    <link href="http://sweetvvck.github.io/2014/08/15/%E8%AF%91-Android%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%89%EF%BC%89%E8%BF%90%E7%94%A8Fragment%E6%9E%84%E5%BB%BA%E5%8A%A8%E6%80%81UI%E2%80%94%E2%80%94Fragment%E9%97%B4%E9%80%9A%E8%AE%AF/"/>
    <id>http://sweetvvck.github.io/2014/08/15/译-Android学习路线（二十三）运用Fragment构建动态UI——Fragment间通讯/</id>
    <published>2014-08-14T16:07:26.000Z</published>
    <updated>2016-01-25T20:06:38.000Z</updated>
    <content type="html"><![CDATA[<p>为了要重用Fragment的UI组件，你应该为它们每一个都构建一个完整独立的，模块化的组件来定义他自身的布局和行为。一旦你定义了这些可重用的Fragments，你可以通过activity关联它们同时通过应用逻辑连接它们来实现所有复杂的UI。</p>
<p>你通常都希望一个fragment能够和其他的fragment进行交互，例如基于用户的操作改变内容。所有的fragment之间的交流的完成都通过activity的关联。两个fragment之间一定不要直接交流。</p>
<h2 id="u5B9A_u4E49_u4E00_u4E2A_u63A5_u53E3"><a href="#u5B9A_u4E49_u4E00_u4E2A_u63A5_u53E3" class="headerlink" title="定义一个接口"></a>定义一个接口</h2><hr>
<p>要允许一个fragment和它的activity通讯，你可以在fragment类中定义一个接口，然后再activity中实现它。Fragment在onAttach()方法中获取这个接口的实现，这样之后就能够调用这些接口来达到和activity通讯的目的。</p>
<p>下面是一个fragment和activity通讯的例子：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class HeadlinesFragment extends ListFragment &#123;</span><br><span class="line">    OnHeadlineSelectedListener mCallback;</span><br><span class="line"></span><br><span class="line">    // Container Activity must implement this interface</span><br><span class="line">    public interface OnHeadlineSelectedListener &#123;</span><br><span class="line">        public void onArticleSelected(int position);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onAttach(Activity activity) &#123;</span><br><span class="line">        super.onAttach(activity);</span><br><span class="line"></span><br><span class="line">        // This makes sure that the container activity has implemented</span><br><span class="line">        // the callback interface. If not, it throws an exception</span><br><span class="line">        try &#123;</span><br><span class="line">            mCallback = (OnHeadlineSelectedListener) activity;</span><br><span class="line">        &#125; catch (ClassCastException e) &#123;</span><br><span class="line">            throw new ClassCastException(activity.toString()</span><br><span class="line">                    &amp;#43; &amp;quot; must implement OnHeadlineSelectedListener&amp;quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在这个fragment可以通过使用onHeadlineSelectedListener接口的实例mCallback来调用<code>onArticleSelected()</code> 方法（或者这个接口中的其它方法）来向activity传递消息了。</p>
<p>例如，当用户点击fragment中列表的item时，下面的方法将会被调用。这个fragment会使用这个回调接口来将事件传递给它的父activity。</p>
<pre><code>@Override
public void onListItemClick(ListView l, View v, int position, long id) {
    // Send the event to the host activity
    mCallback.onArticleSelected(position);
}
</code></pre><h2 id="u5B9E_u73B0_u8FD9_u4E2A_u63A5_u53E3"><a href="#u5B9E_u73B0_u8FD9_u4E2A_u63A5_u53E3" class="headerlink" title="实现这个接口"></a>实现这个接口</h2><hr>
<p>为了接收fragment的回调事件，包含这个fragment的activity就必须实现定义在fragment的接口。</p>
<p>例如，下面的这个activity就实现了上面例子中的接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span></span><br><span class="line">        <span class="keyword">implements</span> <span class="title">HeadlinesFragment</span>.<span class="title">OnHeadlineSelectedListener</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onArticleSelected</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// The user selected the headline of an article from the HeadlinesFragment</span></span><br><span class="line">        <span class="comment">// Do something here to display that article</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="u5411Fragment_u4F20_u9012_u6D88_u606F"><a href="#u5411Fragment_u4F20_u9012_u6D88_u606F" class="headerlink" title="向Fragment传递消息"></a>向Fragment传递消息</h2><hr>
<p>宿主activity可以通过使用<code>[findFragmentById()](http://developer.android.com/reference/android/support/v4/app/FragmentManager.html#findFragmentById(int))</code>获取的fragment实例来向fragment传递消息，然后直接调用这些fragment的public方法。</p>
<p>例如，设想上面的那个activity包含另一个fragment，这个fragment是用来展示通过前面的回调方法返回的数据指定的item。在这个案例中，这个activity可以这个activity可以将接收的这些信息传递给其它的fragment用来显示这个item：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span></span><br><span class="line">        <span class="keyword">implements</span> <span class="title">HeadlinesFragment</span>.<span class="title">OnHeadlineSelectedListener</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onArticleSelected</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// The user selected the headline of an article from the HeadlinesFragment</span></span><br><span class="line">        <span class="comment">// Do something here to display that article</span></span><br><span class="line"></span><br><span class="line">        ArticleFragment articleFrag = (ArticleFragment)</span><br><span class="line">                getSupportFragmentManager().findFragmentById(R.id.article_fragment);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (articleFrag != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// If article frag is available, we're in two-pane layout...</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// Call a method in the ArticleFragment to update its content</span></span><br><span class="line">            articleFrag.updateArticleView(position);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Otherwise, we're in the one-pane layout and must swap frags...</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// Create fragment and give it an argument for the selected article</span></span><br><span class="line">            ArticleFragment newFragment = <span class="keyword">new</span> ArticleFragment();</span><br><span class="line">            Bundle args = <span class="keyword">new</span> Bundle();</span><br><span class="line">            args.putInt(ArticleFragment.ARG_POSITION, position);</span><br><span class="line">            newFragment.setArguments(args);</span><br><span class="line"></span><br><span class="line">            FragmentTransaction transaction = getSupportFragmentManager().beginTransaction();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Replace whatever is in the fragment_container view with this fragment,</span></span><br><span class="line">            <span class="comment">// and add the transaction to the back stack so the user can navigate back</span></span><br><span class="line">            transaction.replace(R.id.fragment_container, newFragment);</span><br><span class="line">            transaction.addToBackStack(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Commit the transaction</span></span><br><span class="line">            transaction.commit();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>    作者：sweetvvck 发表于2014/8/15 0:07:26 [原文链接](http://blog.csdn.net/sweetvvck/article/details/38569351)


阅读：1416 评论：0 [查看评论](http://blog.csdn.net/sweetvvck/article/details/38569351#comments)
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>为了要重用Fragment的UI组件，你应该为它们每一个都构建一个完整独立的，模块化的组件来定义他自身的布局和行为。一旦你定义了这些可重用的Fragments，你可以通过activity关联它们同时通过应用逻辑连接它们来实现所有复杂的UI。</p>
<p>你通常都希望一个f]]>
    </summary>
    
      <category term="Android" scheme="http://sweetvvck.github.io/tags/Android/"/>
    
      <category term="Fragment" scheme="http://sweetvvck.github.io/tags/Fragment/"/>
    
  </entry>
  
</feed>
